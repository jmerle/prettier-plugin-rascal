import { getASTTypes } from './ast-parser';

function getNodeName(parentType: string, subType: string): string {
  return parentType + subType + 'Node';
}

function getTypeName(memberType: string): string {
  if (memberType === 'java.lang.String') {
    return 'string';
  }

  if (memberType.startsWith('java.util.List<')) {
    const innerType = memberType.substring('java.util.List<'.length, memberType.length - 1);
    return getTypeName(innerType) + '[]';
  }

  return memberType.split('.').pop() + 'Node';
}

const types = getASTTypes();

console.log('/* eslint-disable @typescript-eslint/camelcase,@typescript-eslint/class-name-casing */');
console.log();
console.log('// The code in this file is automatically generated by scripts/types-generator.ts');
console.log();
console.log('interface BaseNode {');
console.log('_start: number;');
console.log('_end: number;');
console.log('}\n');

for (const parentType in types) {
  for (const subType in types[parentType]) {
    console.log(`interface ${getNodeName(parentType, subType)} extends BaseNode {`);
    console.log(`_type: '${parentType}.${subType}';`);

    for (const member of types[parentType][subType]) {
      console.log(`${member.name}: ${getTypeName(member.type)};`);
    }

    console.log('}\n');
  }

  const subNodeNames = Object.keys(types[parentType]).map(subType => getNodeName(parentType, subType));
  console.log(`type ${parentType}Node = ${subNodeNames.join(' | ')};\n`);
}

const parentNodeNames = Object.keys(types).map(parentType => parentType + 'Node');
console.log(`type ASTNode = ${parentNodeNames.join(' | ')};`);
