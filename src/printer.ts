// This file is automatically generated by running 'yarn generate:printer'

import { Doc, FastPath, ParserOptions } from 'prettier';
import { printAssignableAnnotationNode, printAssignableBracketNode, printAssignableConstructorNode, printAssignableFieldAccessNode, printAssignableIfDefinedOrDefaultNode, printAssignableSliceNode, printAssignableSliceStepNode, printAssignableSubscriptNode, printAssignableTupleNode, printAssignableVariableNode } from './printers/assignable';
import { printAssignmentAdditionNode, printAssignmentAppendNode, printAssignmentDefaultNode, printAssignmentDivisionNode, printAssignmentIfDefinedNode, printAssignmentIntersectionNode, printAssignmentProductNode, printAssignmentSubtractionNode } from './printers/assignment';
import { printAssocAssociativeNode, printAssocLeftNode, printAssocNonAssociativeNode, printAssocRightNode } from './printers/assoc';
import { printBackslashLexicalNode } from './printers/backslash';
import { printBasicTypeBagNode, printBasicTypeBoolNode, printBasicTypeDateTimeNode, printBasicTypeIntNode, printBasicTypeListNode, printBasicTypeListRelationNode, printBasicTypeLocNode, printBasicTypeMapNode, printBasicTypeNodeNode, printBasicTypeNumNode, printBasicTypeRationalNode, printBasicTypeRealNode, printBasicTypeRelationNode, printBasicTypeSetNode, printBasicTypeStringNode, printBasicTypeTupleNode, printBasicTypeTypeNode, printBasicTypeValueNode, printBasicTypeVoidNode } from './printers/basic-type';
import { printBodyToplevelsNode } from './printers/body';
import { printBooleanLiteralLexicalNode } from './printers/boolean-literal';
import { printBoundDefaultNode, printBoundEmptyNode } from './printers/bound';
import { printCaseDefaultNode, printCasePatternWithActionNode } from './printers/case';
import { printCaseInsensitiveStringConstantLexicalNode } from './printers/case-insensitive-string-constant';
import { printCatchBindingNode, printCatchDefaultNode } from './printers/catch';
import { printCharLexicalNode } from './printers/char';
import { printClassBracketNode, printClassComplementNode, printClassDifferenceNode, printClassIntersectionNode, printClassSimpleCharclassNode, printClassUnionNode } from './printers/class';
import { printCommandDeclarationNode, printCommandExpressionNode, printCommandImportNode, printCommandShellNode, printCommandStatementNode } from './printers/command';
import { printCommandsCommandlistNode } from './printers/commands';
import { printCommentLexicalNode } from './printers/comment';
import { printCommonKeywordParametersAbsentNode, printCommonKeywordParametersPresentNode } from './printers/common-keyword-parameters';
import { printComprehensionListNode, printComprehensionMapNode, printComprehensionSetNode } from './printers/comprehension';
import { printConcreteLexicalNode } from './printers/concrete';
import { printConcreteHoleOneNode } from './printers/concrete-hole';
import { printConcretePartLexicalNode } from './printers/concrete-part';
import { printDataTargetEmptyNode, printDataTargetLabeledNode } from './printers/data-target';
import { printDataTypeSelectorSelectorNode } from './printers/data-type-selector';
import { printDateAndTimeLexicalNode } from './printers/date-and-time';
import { printDatePartLexicalNode } from './printers/date-part';
import { printDateTimeLiteralDateAndTimeLiteralNode, printDateTimeLiteralDateLiteralNode, printDateTimeLiteralTimeLiteralNode } from './printers/date-time-literal';
import { printDecimalIntegerLiteralLexicalNode } from './printers/decimal-integer-literal';
import { printDeclarationAliasNode, printDeclarationAnnotationNode, printDeclarationDataNode, printDeclarationDataAbstractNode, printDeclarationFunctionNode, printDeclarationTagNode, printDeclarationVariableNode } from './printers/declaration';
import { printDeclaratorDefaultNode } from './printers/declarator';
import { printEvalCommandDeclarationNode, printEvalCommandImportNode, printEvalCommandOutputNode, printEvalCommandStatementNode } from './printers/eval-command';
import { printExpressionAdditionNode, printExpressionAllNode, printExpressionAndNode, printExpressionAntiNode, printExpressionAnyNode, printExpressionAppendAfterNode, printExpressionAsTypeNode, printExpressionBracketNode, printExpressionCallOrTreeNode, printExpressionClosureNode, printExpressionCompositionNode, printExpressionComprehensionNode, printExpressionConcreteNode, printExpressionDescendantNode, printExpressionDivisionNode, printExpressionEnumeratorNode, printExpressionEqualsNode, printExpressionEquivalenceNode, printExpressionFieldAccessNode, printExpressionFieldProjectNode, printExpressionFieldUpdateNode, printExpressionGetAnnotationNode, printExpressionGreaterThanNode, printExpressionGreaterThanOrEqNode, printExpressionHasNode, printExpressionIfDefinedOtherwiseNode, printExpressionIfThenElseNode, printExpressionImplicationNode, printExpressionInNode, printExpressionInsertBeforeNode, printExpressionIntersectionNode, printExpressionIsNode, printExpressionIsDefinedNode, printExpressionItNode, printExpressionJoinNode, printExpressionLessThanNode, printExpressionLessThanOrEqNode, printExpressionListNode, printExpressionLiteralNode, printExpressionMapNode, printExpressionMatchNode, printExpressionModuloNode, printExpressionMultiVariableNode, printExpressionNegationNode, printExpressionNegativeNode, printExpressionNoMatchNode, printExpressionNonEmptyBlockNode, printExpressionNonEqualsNode, printExpressionNotInNode, printExpressionOrNode, printExpressionProductNode, printExpressionQualifiedNameNode, printExpressionRangeNode, printExpressionReducerNode, printExpressionReifiedTypeNode, printExpressionReifyTypeNode, printExpressionRemainderNode, printExpressionSetNode, printExpressionSetAnnotationNode, printExpressionSliceNode, printExpressionSliceStepNode, printExpressionSpliceNode, printExpressionSplicePlusNode, printExpressionStepRangeNode, printExpressionSubscriptNode, printExpressionSubtractionNode, printExpressionTransitiveClosureNode, printExpressionTransitiveReflexiveClosureNode, printExpressionTupleNode, printExpressionTypedVariableNode, printExpressionTypedVariableBecomesNode, printExpressionVariableBecomesNode, printExpressionVisitNode, printExpressionVoidClosureNode } from './printers/expression';
import { printFieldIndexNode, printFieldNameNode } from './printers/field';
import { printFormalsDefaultNode } from './printers/formals';
import { printFunctionBodyDefaultNode } from './printers/function-body';
import { printFunctionDeclarationAbstractNode, printFunctionDeclarationConditionalNode, printFunctionDeclarationDefaultNode, printFunctionDeclarationExpressionNode } from './printers/function-declaration';
import { printFunctionModifierDefaultNode, printFunctionModifierJavaNode, printFunctionModifierTestNode } from './printers/function-modifier';
import { printFunctionModifiersModifierlistNode } from './printers/function-modifiers';
import { printFunctionTypeTypeArgumentsNode } from './printers/function-type';
import { printHeaderDefaultNode, printHeaderParametersNode } from './printers/header';
import { printHexIntegerLiteralLexicalNode } from './printers/hex-integer-literal';
import { printImportDefaultNode, printImportExtendNode, printImportExternalNode, printImportSyntaxNode } from './printers/import';
import { printImportedModuleActualsNode, printImportedModuleActualsRenamingNode, printImportedModuleDefaultNode, printImportedModuleRenamingsNode } from './printers/imported-module';
import { printIntegerLiteralDecimalIntegerLiteralNode, printIntegerLiteralHexIntegerLiteralNode, printIntegerLiteralOctalIntegerLiteralNode } from './printers/integer-literal';
import { printJustDateLexicalNode } from './printers/just-date';
import { printJustTimeLexicalNode } from './printers/just-time';
import { printKeywordArgument_ExpressionDefaultNode } from './printers/keyword-argument-expression';
import { printKeywordArguments_ExpressionDefaultNode, printKeywordArguments_ExpressionNoneNode } from './printers/keyword-arguments-expression';
import { printKeywordFormalDefaultNode } from './printers/keyword-formal';
import { printKeywordFormalsDefaultNode, printKeywordFormalsNoneNode } from './printers/keyword-formals';
import { printKindAliasNode, printKindAllNode, printKindAnnoNode, printKindDataNode, printKindFunctionNode, printKindModuleNode, printKindTagNode, printKindVariableNode, printKindViewNode } from './printers/kind';
import { printLAYOUTLexicalNode } from './printers/layout';
import { printLabelDefaultNode, printLabelEmptyNode } from './printers/label';
import { printLiteralBooleanNode, printLiteralDateTimeNode, printLiteralIntegerNode, printLiteralLocationNode, printLiteralRationalNode, printLiteralRealNode, printLiteralRegExpNode, printLiteralStringNode } from './printers/literal';
import { printLocalVariableDeclarationDefaultNode, printLocalVariableDeclarationDynamicNode } from './printers/local-variable-declaration';
import { printLocationLiteralDefaultNode } from './printers/location-literal';
import { printMapping_ExpressionDefaultNode } from './printers/mapping-expression';
import { printMidPathCharsLexicalNode } from './printers/mid-path-chars';
import { printMidProtocolCharsLexicalNode } from './printers/mid-protocol-chars';
import { printMidStringCharsLexicalNode } from './printers/mid-string-chars';
import { printModuleDefaultNode } from './printers/module';
import { printModuleActualsDefaultNode } from './printers/module-actuals';
import { printModuleParametersDefaultNode } from './printers/module-parameters';
import { printNameLexicalNode } from './printers/name';
import { printNamedBackslashLexicalNode } from './printers/named-backslash';
import { printNamedRegExpLexicalNode } from './printers/named-reg-exp';
import { printNonterminalLexicalNode } from './printers/nonterminal';
import { printNonterminalLabelLexicalNode } from './printers/nonterminal-label';
import { printOctalIntegerLiteralLexicalNode } from './printers/octal-integer-literal';
import { printOptionalCommaLexicalNode } from './printers/optional-comma';
import { printOptionalExpressionExpressionNode, printOptionalExpressionNoExpressionNode } from './printers/optional-expression';
import { printOutputLexicalNode } from './printers/output';
import { printParametersDefaultNode, printParametersVarArgsNode } from './printers/parameters';
import { printPathCharsLexicalNode } from './printers/path-chars';
import { printPathPartInterpolatedNode, printPathPartNonInterpolatedNode } from './printers/path-part';
import { printPathTailMidNode, printPathTailPostNode } from './printers/path-tail';
import { printPatternWithActionArbitraryNode, printPatternWithActionReplacingNode } from './printers/pattern-with-action';
import { printPostPathCharsLexicalNode } from './printers/post-path-chars';
import { printPostProtocolCharsLexicalNode } from './printers/post-protocol-chars';
import { printPostStringCharsLexicalNode } from './printers/post-string-chars';
import { printPrePathCharsLexicalNode } from './printers/pre-path-chars';
import { printPreProtocolCharsLexicalNode } from './printers/pre-protocol-chars';
import { printPreStringCharsLexicalNode } from './printers/pre-string-chars';
import { printProdAllNode, printProdAssociativityGroupNode, printProdFirstNode, printProdLabeledNode, printProdReferenceNode, printProdUnlabeledNode } from './printers/prod';
import { printProdModifierAssociativityNode, printProdModifierBracketNode, printProdModifierTagNode } from './printers/prod-modifier';
import { printProtocolCharsLexicalNode } from './printers/protocol-chars';
import { printProtocolPartInterpolatedNode, printProtocolPartNonInterpolatedNode } from './printers/protocol-part';
import { printProtocolTailMidNode, printProtocolTailPostNode } from './printers/protocol-tail';
import { printQualifiedNameDefaultNode } from './printers/qualified-name';
import { printRangeCharacterNode, printRangeFromToNode } from './printers/range';
import { printRationalLiteralLexicalNode } from './printers/rational-literal';
import { printRealLiteralLexicalNode } from './printers/real-literal';
import { printRegExpLexicalNode } from './printers/reg-exp';
import { printRegExpLiteralLexicalNode } from './printers/reg-exp-literal';
import { printRegExpModifierLexicalNode } from './printers/reg-exp-modifier';
import { printRenamingDefaultNode } from './printers/renaming';
import { printRenamingsDefaultNode } from './printers/renamings';
import { printReplacementConditionalNode, printReplacementUnconditionalNode } from './printers/replacement';
import { printShellCommandClearNode, printShellCommandEditNode, printShellCommandHelpNode, printShellCommandHistoryNode, printShellCommandListDeclarationsNode, printShellCommandListModulesNode, printShellCommandQuitNode, printShellCommandSetOptionNode, printShellCommandTestNode, printShellCommandUndeclareNode, printShellCommandUnimportNode } from './printers/shell-command';
import { printSignatureNoThrowsNode, printSignatureWithThrowsNode } from './printers/signature';
import { printStartAbsentNode, printStartPresentNode } from './printers/start';
import { printStatementAppendNode, printStatementAssertNode, printStatementAssertWithMessageNode, printStatementAssignmentNode, printStatementBreakNode, printStatementContinueNode, printStatementDoWhileNode, printStatementEmptyStatementNode, printStatementExpressionNode, printStatementFailNode, printStatementFilterNode, printStatementForNode, printStatementFunctionDeclarationNode, printStatementGlobalDirectiveNode, printStatementIfThenNode, printStatementIfThenElseNode, printStatementInsertNode, printStatementNonEmptyBlockNode, printStatementReturnNode, printStatementSolveNode, printStatementSwitchNode, printStatementThrowNode, printStatementTryNode, printStatementTryFinallyNode, printStatementVariableDeclarationNode, printStatementVisitNode, printStatementWhileNode } from './printers/statement';
import { printStrategyBottomUpNode, printStrategyBottomUpBreakNode, printStrategyInnermostNode, printStrategyOutermostNode, printStrategyTopDownNode, printStrategyTopDownBreakNode } from './printers/strategy';
import { printStringCharacterLexicalNode } from './printers/string-character';
import { printStringConstantLexicalNode } from './printers/string-constant';
import { printStringLiteralInterpolatedNode, printStringLiteralNonInterpolatedNode, printStringLiteralTemplateNode } from './printers/string-literal';
import { printStringMiddleInterpolatedNode, printStringMiddleMidNode, printStringMiddleTemplateNode } from './printers/string-middle';
import { printStringTailMidInterpolatedNode, printStringTailMidTemplateNode, printStringTailPostNode } from './printers/string-tail';
import { printStringTemplateDoWhileNode, printStringTemplateForNode, printStringTemplateIfThenNode, printStringTemplateIfThenElseNode, printStringTemplateWhileNode } from './printers/string-template';
import { printStructuredTypeDefaultNode } from './printers/structured-type';
import { printSymAlternativeNode, printSymCaseInsensitiveLiteralNode, printSymCharacterClassNode, printSymColumnNode, printSymEmptyNode, printSymEndOfLineNode, printSymExceptNode, printSymFollowNode, printSymIterNode, printSymIterSepNode, printSymIterStarNode, printSymIterStarSepNode, printSymLabeledNode, printSymLiteralNode, printSymNonterminalNode, printSymNotFollowNode, printSymNotPrecedeNode, printSymOptionalNode, printSymParameterNode, printSymParametrizedNode, printSymPrecedeNode, printSymSequenceNode, printSymStartNode, printSymStartOfLineNode, printSymUnequalNode } from './printers/sym';
import { printSyntaxDefinitionKeywordNode, printSyntaxDefinitionLanguageNode, printSyntaxDefinitionLayoutNode, printSyntaxDefinitionLexicalNode } from './printers/syntax-definition';
import { printTagDefaultNode, printTagEmptyNode, printTagExpressionNode } from './printers/tag';
import { printTagStringLexicalNode } from './printers/tag-string';
import { printTagsDefaultNode } from './printers/tags';
import { printTargetEmptyNode, printTargetLabeledNode } from './printers/target';
import { printTimePartNoTZLexicalNode } from './printers/time-part-no-tz';
import { printTimeZonePartLexicalNode } from './printers/time-zone-part';
import { printToplevelGivenVisibilityNode } from './printers/toplevel';
import { printTypeBasicNode, printTypeBracketNode, printTypeFunctionNode, printTypeSelectorNode, printTypeStructuredNode, printTypeSymbolNode, printTypeUserNode, printTypeVariableNode } from './printers/type';
import { printTypeArgDefaultNode, printTypeArgNamedNode } from './printers/type-arg';
import { printTypeVarBoundedNode, printTypeVarFreeNode } from './printers/type-var';
import { printURLCharsLexicalNode } from './printers/url-chars';
import { printUnicodeEscapeLexicalNode } from './printers/unicode-escape';
import { printUserTypeNameNode, printUserTypeParametricNode } from './printers/user-type';
import { printVariableInitializedNode, printVariableUnInitializedNode } from './printers/variable';
import { printVariantNAryConstructorNode } from './printers/variant';
import { printVisibilityDefaultNode, printVisibilityPrivateNode, printVisibilityPublicNode } from './printers/visibility';
import { printVisitDefaultStrategyNode, printVisitGivenStrategyNode } from './printers/visit';

export function print(path: FastPath<ASTNode>, options: ParserOptions, print: (path: FastPath<ASTNode>) => Doc): Doc {
const node = path.getValue();

  switch (node._type) {
    case 'Assignable.Annotation':
      return printAssignableAnnotationNode(node, path as FastPath<AssignableAnnotationNode>, options, print);
    case 'Assignable.Bracket':
      return printAssignableBracketNode(node, path as FastPath<AssignableBracketNode>, options, print);
    case 'Assignable.Constructor':
      return printAssignableConstructorNode(node, path as FastPath<AssignableConstructorNode>, options, print);
    case 'Assignable.FieldAccess':
      return printAssignableFieldAccessNode(node, path as FastPath<AssignableFieldAccessNode>, options, print);
    case 'Assignable.IfDefinedOrDefault':
      return printAssignableIfDefinedOrDefaultNode(node, path as FastPath<AssignableIfDefinedOrDefaultNode>, options, print);
    case 'Assignable.Slice':
      return printAssignableSliceNode(node, path as FastPath<AssignableSliceNode>, options, print);
    case 'Assignable.SliceStep':
      return printAssignableSliceStepNode(node, path as FastPath<AssignableSliceStepNode>, options, print);
    case 'Assignable.Subscript':
      return printAssignableSubscriptNode(node, path as FastPath<AssignableSubscriptNode>, options, print);
    case 'Assignable.Tuple':
      return printAssignableTupleNode(node, path as FastPath<AssignableTupleNode>, options, print);
    case 'Assignable.Variable':
      return printAssignableVariableNode(node, path as FastPath<AssignableVariableNode>, options, print);
    case 'Assignment.Addition':
      return printAssignmentAdditionNode(node, path as FastPath<AssignmentAdditionNode>, options, print);
    case 'Assignment.Append':
      return printAssignmentAppendNode(node, path as FastPath<AssignmentAppendNode>, options, print);
    case 'Assignment.Default':
      return printAssignmentDefaultNode(node, path as FastPath<AssignmentDefaultNode>, options, print);
    case 'Assignment.Division':
      return printAssignmentDivisionNode(node, path as FastPath<AssignmentDivisionNode>, options, print);
    case 'Assignment.IfDefined':
      return printAssignmentIfDefinedNode(node, path as FastPath<AssignmentIfDefinedNode>, options, print);
    case 'Assignment.Intersection':
      return printAssignmentIntersectionNode(node, path as FastPath<AssignmentIntersectionNode>, options, print);
    case 'Assignment.Product':
      return printAssignmentProductNode(node, path as FastPath<AssignmentProductNode>, options, print);
    case 'Assignment.Subtraction':
      return printAssignmentSubtractionNode(node, path as FastPath<AssignmentSubtractionNode>, options, print);
    case 'Assoc.Associative':
      return printAssocAssociativeNode(node, path as FastPath<AssocAssociativeNode>, options, print);
    case 'Assoc.Left':
      return printAssocLeftNode(node, path as FastPath<AssocLeftNode>, options, print);
    case 'Assoc.NonAssociative':
      return printAssocNonAssociativeNode(node, path as FastPath<AssocNonAssociativeNode>, options, print);
    case 'Assoc.Right':
      return printAssocRightNode(node, path as FastPath<AssocRightNode>, options, print);
    case 'Backslash.Lexical':
      return printBackslashLexicalNode(node, path as FastPath<BackslashLexicalNode>, options, print);
    case 'BasicType.Bag':
      return printBasicTypeBagNode(node, path as FastPath<BasicTypeBagNode>, options, print);
    case 'BasicType.Bool':
      return printBasicTypeBoolNode(node, path as FastPath<BasicTypeBoolNode>, options, print);
    case 'BasicType.DateTime':
      return printBasicTypeDateTimeNode(node, path as FastPath<BasicTypeDateTimeNode>, options, print);
    case 'BasicType.Int':
      return printBasicTypeIntNode(node, path as FastPath<BasicTypeIntNode>, options, print);
    case 'BasicType.List':
      return printBasicTypeListNode(node, path as FastPath<BasicTypeListNode>, options, print);
    case 'BasicType.ListRelation':
      return printBasicTypeListRelationNode(node, path as FastPath<BasicTypeListRelationNode>, options, print);
    case 'BasicType.Loc':
      return printBasicTypeLocNode(node, path as FastPath<BasicTypeLocNode>, options, print);
    case 'BasicType.Map':
      return printBasicTypeMapNode(node, path as FastPath<BasicTypeMapNode>, options, print);
    case 'BasicType.Node':
      return printBasicTypeNodeNode(node, path as FastPath<BasicTypeNodeNode>, options, print);
    case 'BasicType.Num':
      return printBasicTypeNumNode(node, path as FastPath<BasicTypeNumNode>, options, print);
    case 'BasicType.Rational':
      return printBasicTypeRationalNode(node, path as FastPath<BasicTypeRationalNode>, options, print);
    case 'BasicType.Real':
      return printBasicTypeRealNode(node, path as FastPath<BasicTypeRealNode>, options, print);
    case 'BasicType.Relation':
      return printBasicTypeRelationNode(node, path as FastPath<BasicTypeRelationNode>, options, print);
    case 'BasicType.Set':
      return printBasicTypeSetNode(node, path as FastPath<BasicTypeSetNode>, options, print);
    case 'BasicType.String':
      return printBasicTypeStringNode(node, path as FastPath<BasicTypeStringNode>, options, print);
    case 'BasicType.Tuple':
      return printBasicTypeTupleNode(node, path as FastPath<BasicTypeTupleNode>, options, print);
    case 'BasicType.Type':
      return printBasicTypeTypeNode(node, path as FastPath<BasicTypeTypeNode>, options, print);
    case 'BasicType.Value':
      return printBasicTypeValueNode(node, path as FastPath<BasicTypeValueNode>, options, print);
    case 'BasicType.Void':
      return printBasicTypeVoidNode(node, path as FastPath<BasicTypeVoidNode>, options, print);
    case 'Body.Toplevels':
      return printBodyToplevelsNode(node, path as FastPath<BodyToplevelsNode>, options, print);
    case 'BooleanLiteral.Lexical':
      return printBooleanLiteralLexicalNode(node, path as FastPath<BooleanLiteralLexicalNode>, options, print);
    case 'Bound.Default':
      return printBoundDefaultNode(node, path as FastPath<BoundDefaultNode>, options, print);
    case 'Bound.Empty':
      return printBoundEmptyNode(node, path as FastPath<BoundEmptyNode>, options, print);
    case 'Case.Default':
      return printCaseDefaultNode(node, path as FastPath<CaseDefaultNode>, options, print);
    case 'Case.PatternWithAction':
      return printCasePatternWithActionNode(node, path as FastPath<CasePatternWithActionNode>, options, print);
    case 'CaseInsensitiveStringConstant.Lexical':
      return printCaseInsensitiveStringConstantLexicalNode(node, path as FastPath<CaseInsensitiveStringConstantLexicalNode>, options, print);
    case 'Catch.Binding':
      return printCatchBindingNode(node, path as FastPath<CatchBindingNode>, options, print);
    case 'Catch.Default':
      return printCatchDefaultNode(node, path as FastPath<CatchDefaultNode>, options, print);
    case 'Char.Lexical':
      return printCharLexicalNode(node, path as FastPath<CharLexicalNode>, options, print);
    case 'Class.Bracket':
      return printClassBracketNode(node, path as FastPath<ClassBracketNode>, options, print);
    case 'Class.Complement':
      return printClassComplementNode(node, path as FastPath<ClassComplementNode>, options, print);
    case 'Class.Difference':
      return printClassDifferenceNode(node, path as FastPath<ClassDifferenceNode>, options, print);
    case 'Class.Intersection':
      return printClassIntersectionNode(node, path as FastPath<ClassIntersectionNode>, options, print);
    case 'Class.SimpleCharclass':
      return printClassSimpleCharclassNode(node, path as FastPath<ClassSimpleCharclassNode>, options, print);
    case 'Class.Union':
      return printClassUnionNode(node, path as FastPath<ClassUnionNode>, options, print);
    case 'Command.Declaration':
      return printCommandDeclarationNode(node, path as FastPath<CommandDeclarationNode>, options, print);
    case 'Command.Expression':
      return printCommandExpressionNode(node, path as FastPath<CommandExpressionNode>, options, print);
    case 'Command.Import':
      return printCommandImportNode(node, path as FastPath<CommandImportNode>, options, print);
    case 'Command.Shell':
      return printCommandShellNode(node, path as FastPath<CommandShellNode>, options, print);
    case 'Command.Statement':
      return printCommandStatementNode(node, path as FastPath<CommandStatementNode>, options, print);
    case 'Commands.Commandlist':
      return printCommandsCommandlistNode(node, path as FastPath<CommandsCommandlistNode>, options, print);
    case 'Comment.Lexical':
      return printCommentLexicalNode(node, path as FastPath<CommentLexicalNode>, options, print);
    case 'CommonKeywordParameters.Absent':
      return printCommonKeywordParametersAbsentNode(node, path as FastPath<CommonKeywordParametersAbsentNode>, options, print);
    case 'CommonKeywordParameters.Present':
      return printCommonKeywordParametersPresentNode(node, path as FastPath<CommonKeywordParametersPresentNode>, options, print);
    case 'Comprehension.List':
      return printComprehensionListNode(node, path as FastPath<ComprehensionListNode>, options, print);
    case 'Comprehension.Map':
      return printComprehensionMapNode(node, path as FastPath<ComprehensionMapNode>, options, print);
    case 'Comprehension.Set':
      return printComprehensionSetNode(node, path as FastPath<ComprehensionSetNode>, options, print);
    case 'Concrete.Lexical':
      return printConcreteLexicalNode(node, path as FastPath<ConcreteLexicalNode>, options, print);
    case 'ConcreteHole.One':
      return printConcreteHoleOneNode(node, path as FastPath<ConcreteHoleOneNode>, options, print);
    case 'ConcretePart.Lexical':
      return printConcretePartLexicalNode(node, path as FastPath<ConcretePartLexicalNode>, options, print);
    case 'DataTarget.Empty':
      return printDataTargetEmptyNode(node, path as FastPath<DataTargetEmptyNode>, options, print);
    case 'DataTarget.Labeled':
      return printDataTargetLabeledNode(node, path as FastPath<DataTargetLabeledNode>, options, print);
    case 'DataTypeSelector.Selector':
      return printDataTypeSelectorSelectorNode(node, path as FastPath<DataTypeSelectorSelectorNode>, options, print);
    case 'DateAndTime.Lexical':
      return printDateAndTimeLexicalNode(node, path as FastPath<DateAndTimeLexicalNode>, options, print);
    case 'DatePart.Lexical':
      return printDatePartLexicalNode(node, path as FastPath<DatePartLexicalNode>, options, print);
    case 'DateTimeLiteral.DateAndTimeLiteral':
      return printDateTimeLiteralDateAndTimeLiteralNode(node, path as FastPath<DateTimeLiteralDateAndTimeLiteralNode>, options, print);
    case 'DateTimeLiteral.DateLiteral':
      return printDateTimeLiteralDateLiteralNode(node, path as FastPath<DateTimeLiteralDateLiteralNode>, options, print);
    case 'DateTimeLiteral.TimeLiteral':
      return printDateTimeLiteralTimeLiteralNode(node, path as FastPath<DateTimeLiteralTimeLiteralNode>, options, print);
    case 'DecimalIntegerLiteral.Lexical':
      return printDecimalIntegerLiteralLexicalNode(node, path as FastPath<DecimalIntegerLiteralLexicalNode>, options, print);
    case 'Declaration.Alias':
      return printDeclarationAliasNode(node, path as FastPath<DeclarationAliasNode>, options, print);
    case 'Declaration.Annotation':
      return printDeclarationAnnotationNode(node, path as FastPath<DeclarationAnnotationNode>, options, print);
    case 'Declaration.Data':
      return printDeclarationDataNode(node, path as FastPath<DeclarationDataNode>, options, print);
    case 'Declaration.DataAbstract':
      return printDeclarationDataAbstractNode(node, path as FastPath<DeclarationDataAbstractNode>, options, print);
    case 'Declaration.Function':
      return printDeclarationFunctionNode(node, path as FastPath<DeclarationFunctionNode>, options, print);
    case 'Declaration.Tag':
      return printDeclarationTagNode(node, path as FastPath<DeclarationTagNode>, options, print);
    case 'Declaration.Variable':
      return printDeclarationVariableNode(node, path as FastPath<DeclarationVariableNode>, options, print);
    case 'Declarator.Default':
      return printDeclaratorDefaultNode(node, path as FastPath<DeclaratorDefaultNode>, options, print);
    case 'EvalCommand.Declaration':
      return printEvalCommandDeclarationNode(node, path as FastPath<EvalCommandDeclarationNode>, options, print);
    case 'EvalCommand.Import':
      return printEvalCommandImportNode(node, path as FastPath<EvalCommandImportNode>, options, print);
    case 'EvalCommand.Output':
      return printEvalCommandOutputNode(node, path as FastPath<EvalCommandOutputNode>, options, print);
    case 'EvalCommand.Statement':
      return printEvalCommandStatementNode(node, path as FastPath<EvalCommandStatementNode>, options, print);
    case 'Expression.Addition':
      return printExpressionAdditionNode(node, path as FastPath<ExpressionAdditionNode>, options, print);
    case 'Expression.All':
      return printExpressionAllNode(node, path as FastPath<ExpressionAllNode>, options, print);
    case 'Expression.And':
      return printExpressionAndNode(node, path as FastPath<ExpressionAndNode>, options, print);
    case 'Expression.Anti':
      return printExpressionAntiNode(node, path as FastPath<ExpressionAntiNode>, options, print);
    case 'Expression.Any':
      return printExpressionAnyNode(node, path as FastPath<ExpressionAnyNode>, options, print);
    case 'Expression.AppendAfter':
      return printExpressionAppendAfterNode(node, path as FastPath<ExpressionAppendAfterNode>, options, print);
    case 'Expression.AsType':
      return printExpressionAsTypeNode(node, path as FastPath<ExpressionAsTypeNode>, options, print);
    case 'Expression.Bracket':
      return printExpressionBracketNode(node, path as FastPath<ExpressionBracketNode>, options, print);
    case 'Expression.CallOrTree':
      return printExpressionCallOrTreeNode(node, path as FastPath<ExpressionCallOrTreeNode>, options, print);
    case 'Expression.Closure':
      return printExpressionClosureNode(node, path as FastPath<ExpressionClosureNode>, options, print);
    case 'Expression.Composition':
      return printExpressionCompositionNode(node, path as FastPath<ExpressionCompositionNode>, options, print);
    case 'Expression.Comprehension':
      return printExpressionComprehensionNode(node, path as FastPath<ExpressionComprehensionNode>, options, print);
    case 'Expression.Concrete':
      return printExpressionConcreteNode(node, path as FastPath<ExpressionConcreteNode>, options, print);
    case 'Expression.Descendant':
      return printExpressionDescendantNode(node, path as FastPath<ExpressionDescendantNode>, options, print);
    case 'Expression.Division':
      return printExpressionDivisionNode(node, path as FastPath<ExpressionDivisionNode>, options, print);
    case 'Expression.Enumerator':
      return printExpressionEnumeratorNode(node, path as FastPath<ExpressionEnumeratorNode>, options, print);
    case 'Expression.Equals':
      return printExpressionEqualsNode(node, path as FastPath<ExpressionEqualsNode>, options, print);
    case 'Expression.Equivalence':
      return printExpressionEquivalenceNode(node, path as FastPath<ExpressionEquivalenceNode>, options, print);
    case 'Expression.FieldAccess':
      return printExpressionFieldAccessNode(node, path as FastPath<ExpressionFieldAccessNode>, options, print);
    case 'Expression.FieldProject':
      return printExpressionFieldProjectNode(node, path as FastPath<ExpressionFieldProjectNode>, options, print);
    case 'Expression.FieldUpdate':
      return printExpressionFieldUpdateNode(node, path as FastPath<ExpressionFieldUpdateNode>, options, print);
    case 'Expression.GetAnnotation':
      return printExpressionGetAnnotationNode(node, path as FastPath<ExpressionGetAnnotationNode>, options, print);
    case 'Expression.GreaterThan':
      return printExpressionGreaterThanNode(node, path as FastPath<ExpressionGreaterThanNode>, options, print);
    case 'Expression.GreaterThanOrEq':
      return printExpressionGreaterThanOrEqNode(node, path as FastPath<ExpressionGreaterThanOrEqNode>, options, print);
    case 'Expression.Has':
      return printExpressionHasNode(node, path as FastPath<ExpressionHasNode>, options, print);
    case 'Expression.IfDefinedOtherwise':
      return printExpressionIfDefinedOtherwiseNode(node, path as FastPath<ExpressionIfDefinedOtherwiseNode>, options, print);
    case 'Expression.IfThenElse':
      return printExpressionIfThenElseNode(node, path as FastPath<ExpressionIfThenElseNode>, options, print);
    case 'Expression.Implication':
      return printExpressionImplicationNode(node, path as FastPath<ExpressionImplicationNode>, options, print);
    case 'Expression.In':
      return printExpressionInNode(node, path as FastPath<ExpressionInNode>, options, print);
    case 'Expression.InsertBefore':
      return printExpressionInsertBeforeNode(node, path as FastPath<ExpressionInsertBeforeNode>, options, print);
    case 'Expression.Intersection':
      return printExpressionIntersectionNode(node, path as FastPath<ExpressionIntersectionNode>, options, print);
    case 'Expression.Is':
      return printExpressionIsNode(node, path as FastPath<ExpressionIsNode>, options, print);
    case 'Expression.IsDefined':
      return printExpressionIsDefinedNode(node, path as FastPath<ExpressionIsDefinedNode>, options, print);
    case 'Expression.It':
      return printExpressionItNode(node, path as FastPath<ExpressionItNode>, options, print);
    case 'Expression.Join':
      return printExpressionJoinNode(node, path as FastPath<ExpressionJoinNode>, options, print);
    case 'Expression.LessThan':
      return printExpressionLessThanNode(node, path as FastPath<ExpressionLessThanNode>, options, print);
    case 'Expression.LessThanOrEq':
      return printExpressionLessThanOrEqNode(node, path as FastPath<ExpressionLessThanOrEqNode>, options, print);
    case 'Expression.List':
      return printExpressionListNode(node, path as FastPath<ExpressionListNode>, options, print);
    case 'Expression.Literal':
      return printExpressionLiteralNode(node, path as FastPath<ExpressionLiteralNode>, options, print);
    case 'Expression.Map':
      return printExpressionMapNode(node, path as FastPath<ExpressionMapNode>, options, print);
    case 'Expression.Match':
      return printExpressionMatchNode(node, path as FastPath<ExpressionMatchNode>, options, print);
    case 'Expression.Modulo':
      return printExpressionModuloNode(node, path as FastPath<ExpressionModuloNode>, options, print);
    case 'Expression.MultiVariable':
      return printExpressionMultiVariableNode(node, path as FastPath<ExpressionMultiVariableNode>, options, print);
    case 'Expression.Negation':
      return printExpressionNegationNode(node, path as FastPath<ExpressionNegationNode>, options, print);
    case 'Expression.Negative':
      return printExpressionNegativeNode(node, path as FastPath<ExpressionNegativeNode>, options, print);
    case 'Expression.NoMatch':
      return printExpressionNoMatchNode(node, path as FastPath<ExpressionNoMatchNode>, options, print);
    case 'Expression.NonEmptyBlock':
      return printExpressionNonEmptyBlockNode(node, path as FastPath<ExpressionNonEmptyBlockNode>, options, print);
    case 'Expression.NonEquals':
      return printExpressionNonEqualsNode(node, path as FastPath<ExpressionNonEqualsNode>, options, print);
    case 'Expression.NotIn':
      return printExpressionNotInNode(node, path as FastPath<ExpressionNotInNode>, options, print);
    case 'Expression.Or':
      return printExpressionOrNode(node, path as FastPath<ExpressionOrNode>, options, print);
    case 'Expression.Product':
      return printExpressionProductNode(node, path as FastPath<ExpressionProductNode>, options, print);
    case 'Expression.QualifiedName':
      return printExpressionQualifiedNameNode(node, path as FastPath<ExpressionQualifiedNameNode>, options, print);
    case 'Expression.Range':
      return printExpressionRangeNode(node, path as FastPath<ExpressionRangeNode>, options, print);
    case 'Expression.Reducer':
      return printExpressionReducerNode(node, path as FastPath<ExpressionReducerNode>, options, print);
    case 'Expression.ReifiedType':
      return printExpressionReifiedTypeNode(node, path as FastPath<ExpressionReifiedTypeNode>, options, print);
    case 'Expression.ReifyType':
      return printExpressionReifyTypeNode(node, path as FastPath<ExpressionReifyTypeNode>, options, print);
    case 'Expression.Remainder':
      return printExpressionRemainderNode(node, path as FastPath<ExpressionRemainderNode>, options, print);
    case 'Expression.Set':
      return printExpressionSetNode(node, path as FastPath<ExpressionSetNode>, options, print);
    case 'Expression.SetAnnotation':
      return printExpressionSetAnnotationNode(node, path as FastPath<ExpressionSetAnnotationNode>, options, print);
    case 'Expression.Slice':
      return printExpressionSliceNode(node, path as FastPath<ExpressionSliceNode>, options, print);
    case 'Expression.SliceStep':
      return printExpressionSliceStepNode(node, path as FastPath<ExpressionSliceStepNode>, options, print);
    case 'Expression.Splice':
      return printExpressionSpliceNode(node, path as FastPath<ExpressionSpliceNode>, options, print);
    case 'Expression.SplicePlus':
      return printExpressionSplicePlusNode(node, path as FastPath<ExpressionSplicePlusNode>, options, print);
    case 'Expression.StepRange':
      return printExpressionStepRangeNode(node, path as FastPath<ExpressionStepRangeNode>, options, print);
    case 'Expression.Subscript':
      return printExpressionSubscriptNode(node, path as FastPath<ExpressionSubscriptNode>, options, print);
    case 'Expression.Subtraction':
      return printExpressionSubtractionNode(node, path as FastPath<ExpressionSubtractionNode>, options, print);
    case 'Expression.TransitiveClosure':
      return printExpressionTransitiveClosureNode(node, path as FastPath<ExpressionTransitiveClosureNode>, options, print);
    case 'Expression.TransitiveReflexiveClosure':
      return printExpressionTransitiveReflexiveClosureNode(node, path as FastPath<ExpressionTransitiveReflexiveClosureNode>, options, print);
    case 'Expression.Tuple':
      return printExpressionTupleNode(node, path as FastPath<ExpressionTupleNode>, options, print);
    case 'Expression.TypedVariable':
      return printExpressionTypedVariableNode(node, path as FastPath<ExpressionTypedVariableNode>, options, print);
    case 'Expression.TypedVariableBecomes':
      return printExpressionTypedVariableBecomesNode(node, path as FastPath<ExpressionTypedVariableBecomesNode>, options, print);
    case 'Expression.VariableBecomes':
      return printExpressionVariableBecomesNode(node, path as FastPath<ExpressionVariableBecomesNode>, options, print);
    case 'Expression.Visit':
      return printExpressionVisitNode(node, path as FastPath<ExpressionVisitNode>, options, print);
    case 'Expression.VoidClosure':
      return printExpressionVoidClosureNode(node, path as FastPath<ExpressionVoidClosureNode>, options, print);
    case 'Field.Index':
      return printFieldIndexNode(node, path as FastPath<FieldIndexNode>, options, print);
    case 'Field.Name':
      return printFieldNameNode(node, path as FastPath<FieldNameNode>, options, print);
    case 'Formals.Default':
      return printFormalsDefaultNode(node, path as FastPath<FormalsDefaultNode>, options, print);
    case 'FunctionBody.Default':
      return printFunctionBodyDefaultNode(node, path as FastPath<FunctionBodyDefaultNode>, options, print);
    case 'FunctionDeclaration.Abstract':
      return printFunctionDeclarationAbstractNode(node, path as FastPath<FunctionDeclarationAbstractNode>, options, print);
    case 'FunctionDeclaration.Conditional':
      return printFunctionDeclarationConditionalNode(node, path as FastPath<FunctionDeclarationConditionalNode>, options, print);
    case 'FunctionDeclaration.Default':
      return printFunctionDeclarationDefaultNode(node, path as FastPath<FunctionDeclarationDefaultNode>, options, print);
    case 'FunctionDeclaration.Expression':
      return printFunctionDeclarationExpressionNode(node, path as FastPath<FunctionDeclarationExpressionNode>, options, print);
    case 'FunctionModifier.Default':
      return printFunctionModifierDefaultNode(node, path as FastPath<FunctionModifierDefaultNode>, options, print);
    case 'FunctionModifier.Java':
      return printFunctionModifierJavaNode(node, path as FastPath<FunctionModifierJavaNode>, options, print);
    case 'FunctionModifier.Test':
      return printFunctionModifierTestNode(node, path as FastPath<FunctionModifierTestNode>, options, print);
    case 'FunctionModifiers.Modifierlist':
      return printFunctionModifiersModifierlistNode(node, path as FastPath<FunctionModifiersModifierlistNode>, options, print);
    case 'FunctionType.TypeArguments':
      return printFunctionTypeTypeArgumentsNode(node, path as FastPath<FunctionTypeTypeArgumentsNode>, options, print);
    case 'Header.Default':
      return printHeaderDefaultNode(node, path as FastPath<HeaderDefaultNode>, options, print);
    case 'Header.Parameters':
      return printHeaderParametersNode(node, path as FastPath<HeaderParametersNode>, options, print);
    case 'HexIntegerLiteral.Lexical':
      return printHexIntegerLiteralLexicalNode(node, path as FastPath<HexIntegerLiteralLexicalNode>, options, print);
    case 'Import.Default':
      return printImportDefaultNode(node, path as FastPath<ImportDefaultNode>, options, print);
    case 'Import.Extend':
      return printImportExtendNode(node, path as FastPath<ImportExtendNode>, options, print);
    case 'Import.External':
      return printImportExternalNode(node, path as FastPath<ImportExternalNode>, options, print);
    case 'Import.Syntax':
      return printImportSyntaxNode(node, path as FastPath<ImportSyntaxNode>, options, print);
    case 'ImportedModule.Actuals':
      return printImportedModuleActualsNode(node, path as FastPath<ImportedModuleActualsNode>, options, print);
    case 'ImportedModule.ActualsRenaming':
      return printImportedModuleActualsRenamingNode(node, path as FastPath<ImportedModuleActualsRenamingNode>, options, print);
    case 'ImportedModule.Default':
      return printImportedModuleDefaultNode(node, path as FastPath<ImportedModuleDefaultNode>, options, print);
    case 'ImportedModule.Renamings':
      return printImportedModuleRenamingsNode(node, path as FastPath<ImportedModuleRenamingsNode>, options, print);
    case 'IntegerLiteral.DecimalIntegerLiteral':
      return printIntegerLiteralDecimalIntegerLiteralNode(node, path as FastPath<IntegerLiteralDecimalIntegerLiteralNode>, options, print);
    case 'IntegerLiteral.HexIntegerLiteral':
      return printIntegerLiteralHexIntegerLiteralNode(node, path as FastPath<IntegerLiteralHexIntegerLiteralNode>, options, print);
    case 'IntegerLiteral.OctalIntegerLiteral':
      return printIntegerLiteralOctalIntegerLiteralNode(node, path as FastPath<IntegerLiteralOctalIntegerLiteralNode>, options, print);
    case 'JustDate.Lexical':
      return printJustDateLexicalNode(node, path as FastPath<JustDateLexicalNode>, options, print);
    case 'JustTime.Lexical':
      return printJustTimeLexicalNode(node, path as FastPath<JustTimeLexicalNode>, options, print);
    case 'KeywordArgument_Expression.Default':
      return printKeywordArgument_ExpressionDefaultNode(node, path as FastPath<KeywordArgument_ExpressionDefaultNode>, options, print);
    case 'KeywordArguments_Expression.Default':
      return printKeywordArguments_ExpressionDefaultNode(node, path as FastPath<KeywordArguments_ExpressionDefaultNode>, options, print);
    case 'KeywordArguments_Expression.None':
      return printKeywordArguments_ExpressionNoneNode(node, path as FastPath<KeywordArguments_ExpressionNoneNode>, options, print);
    case 'KeywordFormal.Default':
      return printKeywordFormalDefaultNode(node, path as FastPath<KeywordFormalDefaultNode>, options, print);
    case 'KeywordFormals.Default':
      return printKeywordFormalsDefaultNode(node, path as FastPath<KeywordFormalsDefaultNode>, options, print);
    case 'KeywordFormals.None':
      return printKeywordFormalsNoneNode(node, path as FastPath<KeywordFormalsNoneNode>, options, print);
    case 'Kind.Alias':
      return printKindAliasNode(node, path as FastPath<KindAliasNode>, options, print);
    case 'Kind.All':
      return printKindAllNode(node, path as FastPath<KindAllNode>, options, print);
    case 'Kind.Anno':
      return printKindAnnoNode(node, path as FastPath<KindAnnoNode>, options, print);
    case 'Kind.Data':
      return printKindDataNode(node, path as FastPath<KindDataNode>, options, print);
    case 'Kind.Function':
      return printKindFunctionNode(node, path as FastPath<KindFunctionNode>, options, print);
    case 'Kind.Module':
      return printKindModuleNode(node, path as FastPath<KindModuleNode>, options, print);
    case 'Kind.Tag':
      return printKindTagNode(node, path as FastPath<KindTagNode>, options, print);
    case 'Kind.Variable':
      return printKindVariableNode(node, path as FastPath<KindVariableNode>, options, print);
    case 'Kind.View':
      return printKindViewNode(node, path as FastPath<KindViewNode>, options, print);
    case 'LAYOUT.Lexical':
      return printLAYOUTLexicalNode(node, path as FastPath<LAYOUTLexicalNode>, options, print);
    case 'Label.Default':
      return printLabelDefaultNode(node, path as FastPath<LabelDefaultNode>, options, print);
    case 'Label.Empty':
      return printLabelEmptyNode(node, path as FastPath<LabelEmptyNode>, options, print);
    case 'Literal.Boolean':
      return printLiteralBooleanNode(node, path as FastPath<LiteralBooleanNode>, options, print);
    case 'Literal.DateTime':
      return printLiteralDateTimeNode(node, path as FastPath<LiteralDateTimeNode>, options, print);
    case 'Literal.Integer':
      return printLiteralIntegerNode(node, path as FastPath<LiteralIntegerNode>, options, print);
    case 'Literal.Location':
      return printLiteralLocationNode(node, path as FastPath<LiteralLocationNode>, options, print);
    case 'Literal.Rational':
      return printLiteralRationalNode(node, path as FastPath<LiteralRationalNode>, options, print);
    case 'Literal.Real':
      return printLiteralRealNode(node, path as FastPath<LiteralRealNode>, options, print);
    case 'Literal.RegExp':
      return printLiteralRegExpNode(node, path as FastPath<LiteralRegExpNode>, options, print);
    case 'Literal.String':
      return printLiteralStringNode(node, path as FastPath<LiteralStringNode>, options, print);
    case 'LocalVariableDeclaration.Default':
      return printLocalVariableDeclarationDefaultNode(node, path as FastPath<LocalVariableDeclarationDefaultNode>, options, print);
    case 'LocalVariableDeclaration.Dynamic':
      return printLocalVariableDeclarationDynamicNode(node, path as FastPath<LocalVariableDeclarationDynamicNode>, options, print);
    case 'LocationLiteral.Default':
      return printLocationLiteralDefaultNode(node, path as FastPath<LocationLiteralDefaultNode>, options, print);
    case 'Mapping_Expression.Default':
      return printMapping_ExpressionDefaultNode(node, path as FastPath<Mapping_ExpressionDefaultNode>, options, print);
    case 'MidPathChars.Lexical':
      return printMidPathCharsLexicalNode(node, path as FastPath<MidPathCharsLexicalNode>, options, print);
    case 'MidProtocolChars.Lexical':
      return printMidProtocolCharsLexicalNode(node, path as FastPath<MidProtocolCharsLexicalNode>, options, print);
    case 'MidStringChars.Lexical':
      return printMidStringCharsLexicalNode(node, path as FastPath<MidStringCharsLexicalNode>, options, print);
    case 'Module.Default':
      return printModuleDefaultNode(node, path as FastPath<ModuleDefaultNode>, options, print);
    case 'ModuleActuals.Default':
      return printModuleActualsDefaultNode(node, path as FastPath<ModuleActualsDefaultNode>, options, print);
    case 'ModuleParameters.Default':
      return printModuleParametersDefaultNode(node, path as FastPath<ModuleParametersDefaultNode>, options, print);
    case 'Name.Lexical':
      return printNameLexicalNode(node, path as FastPath<NameLexicalNode>, options, print);
    case 'NamedBackslash.Lexical':
      return printNamedBackslashLexicalNode(node, path as FastPath<NamedBackslashLexicalNode>, options, print);
    case 'NamedRegExp.Lexical':
      return printNamedRegExpLexicalNode(node, path as FastPath<NamedRegExpLexicalNode>, options, print);
    case 'Nonterminal.Lexical':
      return printNonterminalLexicalNode(node, path as FastPath<NonterminalLexicalNode>, options, print);
    case 'NonterminalLabel.Lexical':
      return printNonterminalLabelLexicalNode(node, path as FastPath<NonterminalLabelLexicalNode>, options, print);
    case 'OctalIntegerLiteral.Lexical':
      return printOctalIntegerLiteralLexicalNode(node, path as FastPath<OctalIntegerLiteralLexicalNode>, options, print);
    case 'OptionalComma.Lexical':
      return printOptionalCommaLexicalNode(node, path as FastPath<OptionalCommaLexicalNode>, options, print);
    case 'OptionalExpression.Expression':
      return printOptionalExpressionExpressionNode(node, path as FastPath<OptionalExpressionExpressionNode>, options, print);
    case 'OptionalExpression.NoExpression':
      return printOptionalExpressionNoExpressionNode(node, path as FastPath<OptionalExpressionNoExpressionNode>, options, print);
    case 'Output.Lexical':
      return printOutputLexicalNode(node, path as FastPath<OutputLexicalNode>, options, print);
    case 'Parameters.Default':
      return printParametersDefaultNode(node, path as FastPath<ParametersDefaultNode>, options, print);
    case 'Parameters.VarArgs':
      return printParametersVarArgsNode(node, path as FastPath<ParametersVarArgsNode>, options, print);
    case 'PathChars.Lexical':
      return printPathCharsLexicalNode(node, path as FastPath<PathCharsLexicalNode>, options, print);
    case 'PathPart.Interpolated':
      return printPathPartInterpolatedNode(node, path as FastPath<PathPartInterpolatedNode>, options, print);
    case 'PathPart.NonInterpolated':
      return printPathPartNonInterpolatedNode(node, path as FastPath<PathPartNonInterpolatedNode>, options, print);
    case 'PathTail.Mid':
      return printPathTailMidNode(node, path as FastPath<PathTailMidNode>, options, print);
    case 'PathTail.Post':
      return printPathTailPostNode(node, path as FastPath<PathTailPostNode>, options, print);
    case 'PatternWithAction.Arbitrary':
      return printPatternWithActionArbitraryNode(node, path as FastPath<PatternWithActionArbitraryNode>, options, print);
    case 'PatternWithAction.Replacing':
      return printPatternWithActionReplacingNode(node, path as FastPath<PatternWithActionReplacingNode>, options, print);
    case 'PostPathChars.Lexical':
      return printPostPathCharsLexicalNode(node, path as FastPath<PostPathCharsLexicalNode>, options, print);
    case 'PostProtocolChars.Lexical':
      return printPostProtocolCharsLexicalNode(node, path as FastPath<PostProtocolCharsLexicalNode>, options, print);
    case 'PostStringChars.Lexical':
      return printPostStringCharsLexicalNode(node, path as FastPath<PostStringCharsLexicalNode>, options, print);
    case 'PrePathChars.Lexical':
      return printPrePathCharsLexicalNode(node, path as FastPath<PrePathCharsLexicalNode>, options, print);
    case 'PreProtocolChars.Lexical':
      return printPreProtocolCharsLexicalNode(node, path as FastPath<PreProtocolCharsLexicalNode>, options, print);
    case 'PreStringChars.Lexical':
      return printPreStringCharsLexicalNode(node, path as FastPath<PreStringCharsLexicalNode>, options, print);
    case 'Prod.All':
      return printProdAllNode(node, path as FastPath<ProdAllNode>, options, print);
    case 'Prod.AssociativityGroup':
      return printProdAssociativityGroupNode(node, path as FastPath<ProdAssociativityGroupNode>, options, print);
    case 'Prod.First':
      return printProdFirstNode(node, path as FastPath<ProdFirstNode>, options, print);
    case 'Prod.Labeled':
      return printProdLabeledNode(node, path as FastPath<ProdLabeledNode>, options, print);
    case 'Prod.Reference':
      return printProdReferenceNode(node, path as FastPath<ProdReferenceNode>, options, print);
    case 'Prod.Unlabeled':
      return printProdUnlabeledNode(node, path as FastPath<ProdUnlabeledNode>, options, print);
    case 'ProdModifier.Associativity':
      return printProdModifierAssociativityNode(node, path as FastPath<ProdModifierAssociativityNode>, options, print);
    case 'ProdModifier.Bracket':
      return printProdModifierBracketNode(node, path as FastPath<ProdModifierBracketNode>, options, print);
    case 'ProdModifier.Tag':
      return printProdModifierTagNode(node, path as FastPath<ProdModifierTagNode>, options, print);
    case 'ProtocolChars.Lexical':
      return printProtocolCharsLexicalNode(node, path as FastPath<ProtocolCharsLexicalNode>, options, print);
    case 'ProtocolPart.Interpolated':
      return printProtocolPartInterpolatedNode(node, path as FastPath<ProtocolPartInterpolatedNode>, options, print);
    case 'ProtocolPart.NonInterpolated':
      return printProtocolPartNonInterpolatedNode(node, path as FastPath<ProtocolPartNonInterpolatedNode>, options, print);
    case 'ProtocolTail.Mid':
      return printProtocolTailMidNode(node, path as FastPath<ProtocolTailMidNode>, options, print);
    case 'ProtocolTail.Post':
      return printProtocolTailPostNode(node, path as FastPath<ProtocolTailPostNode>, options, print);
    case 'QualifiedName.Default':
      return printQualifiedNameDefaultNode(node, path as FastPath<QualifiedNameDefaultNode>, options, print);
    case 'Range.Character':
      return printRangeCharacterNode(node, path as FastPath<RangeCharacterNode>, options, print);
    case 'Range.FromTo':
      return printRangeFromToNode(node, path as FastPath<RangeFromToNode>, options, print);
    case 'RationalLiteral.Lexical':
      return printRationalLiteralLexicalNode(node, path as FastPath<RationalLiteralLexicalNode>, options, print);
    case 'RealLiteral.Lexical':
      return printRealLiteralLexicalNode(node, path as FastPath<RealLiteralLexicalNode>, options, print);
    case 'RegExp.Lexical':
      return printRegExpLexicalNode(node, path as FastPath<RegExpLexicalNode>, options, print);
    case 'RegExpLiteral.Lexical':
      return printRegExpLiteralLexicalNode(node, path as FastPath<RegExpLiteralLexicalNode>, options, print);
    case 'RegExpModifier.Lexical':
      return printRegExpModifierLexicalNode(node, path as FastPath<RegExpModifierLexicalNode>, options, print);
    case 'Renaming.Default':
      return printRenamingDefaultNode(node, path as FastPath<RenamingDefaultNode>, options, print);
    case 'Renamings.Default':
      return printRenamingsDefaultNode(node, path as FastPath<RenamingsDefaultNode>, options, print);
    case 'Replacement.Conditional':
      return printReplacementConditionalNode(node, path as FastPath<ReplacementConditionalNode>, options, print);
    case 'Replacement.Unconditional':
      return printReplacementUnconditionalNode(node, path as FastPath<ReplacementUnconditionalNode>, options, print);
    case 'ShellCommand.Clear':
      return printShellCommandClearNode(node, path as FastPath<ShellCommandClearNode>, options, print);
    case 'ShellCommand.Edit':
      return printShellCommandEditNode(node, path as FastPath<ShellCommandEditNode>, options, print);
    case 'ShellCommand.Help':
      return printShellCommandHelpNode(node, path as FastPath<ShellCommandHelpNode>, options, print);
    case 'ShellCommand.History':
      return printShellCommandHistoryNode(node, path as FastPath<ShellCommandHistoryNode>, options, print);
    case 'ShellCommand.ListDeclarations':
      return printShellCommandListDeclarationsNode(node, path as FastPath<ShellCommandListDeclarationsNode>, options, print);
    case 'ShellCommand.ListModules':
      return printShellCommandListModulesNode(node, path as FastPath<ShellCommandListModulesNode>, options, print);
    case 'ShellCommand.Quit':
      return printShellCommandQuitNode(node, path as FastPath<ShellCommandQuitNode>, options, print);
    case 'ShellCommand.SetOption':
      return printShellCommandSetOptionNode(node, path as FastPath<ShellCommandSetOptionNode>, options, print);
    case 'ShellCommand.Test':
      return printShellCommandTestNode(node, path as FastPath<ShellCommandTestNode>, options, print);
    case 'ShellCommand.Undeclare':
      return printShellCommandUndeclareNode(node, path as FastPath<ShellCommandUndeclareNode>, options, print);
    case 'ShellCommand.Unimport':
      return printShellCommandUnimportNode(node, path as FastPath<ShellCommandUnimportNode>, options, print);
    case 'Signature.NoThrows':
      return printSignatureNoThrowsNode(node, path as FastPath<SignatureNoThrowsNode>, options, print);
    case 'Signature.WithThrows':
      return printSignatureWithThrowsNode(node, path as FastPath<SignatureWithThrowsNode>, options, print);
    case 'Start.Absent':
      return printStartAbsentNode(node, path as FastPath<StartAbsentNode>, options, print);
    case 'Start.Present':
      return printStartPresentNode(node, path as FastPath<StartPresentNode>, options, print);
    case 'Statement.Append':
      return printStatementAppendNode(node, path as FastPath<StatementAppendNode>, options, print);
    case 'Statement.Assert':
      return printStatementAssertNode(node, path as FastPath<StatementAssertNode>, options, print);
    case 'Statement.AssertWithMessage':
      return printStatementAssertWithMessageNode(node, path as FastPath<StatementAssertWithMessageNode>, options, print);
    case 'Statement.Assignment':
      return printStatementAssignmentNode(node, path as FastPath<StatementAssignmentNode>, options, print);
    case 'Statement.Break':
      return printStatementBreakNode(node, path as FastPath<StatementBreakNode>, options, print);
    case 'Statement.Continue':
      return printStatementContinueNode(node, path as FastPath<StatementContinueNode>, options, print);
    case 'Statement.DoWhile':
      return printStatementDoWhileNode(node, path as FastPath<StatementDoWhileNode>, options, print);
    case 'Statement.EmptyStatement':
      return printStatementEmptyStatementNode(node, path as FastPath<StatementEmptyStatementNode>, options, print);
    case 'Statement.Expression':
      return printStatementExpressionNode(node, path as FastPath<StatementExpressionNode>, options, print);
    case 'Statement.Fail':
      return printStatementFailNode(node, path as FastPath<StatementFailNode>, options, print);
    case 'Statement.Filter':
      return printStatementFilterNode(node, path as FastPath<StatementFilterNode>, options, print);
    case 'Statement.For':
      return printStatementForNode(node, path as FastPath<StatementForNode>, options, print);
    case 'Statement.FunctionDeclaration':
      return printStatementFunctionDeclarationNode(node, path as FastPath<StatementFunctionDeclarationNode>, options, print);
    case 'Statement.GlobalDirective':
      return printStatementGlobalDirectiveNode(node, path as FastPath<StatementGlobalDirectiveNode>, options, print);
    case 'Statement.IfThen':
      return printStatementIfThenNode(node, path as FastPath<StatementIfThenNode>, options, print);
    case 'Statement.IfThenElse':
      return printStatementIfThenElseNode(node, path as FastPath<StatementIfThenElseNode>, options, print);
    case 'Statement.Insert':
      return printStatementInsertNode(node, path as FastPath<StatementInsertNode>, options, print);
    case 'Statement.NonEmptyBlock':
      return printStatementNonEmptyBlockNode(node, path as FastPath<StatementNonEmptyBlockNode>, options, print);
    case 'Statement.Return':
      return printStatementReturnNode(node, path as FastPath<StatementReturnNode>, options, print);
    case 'Statement.Solve':
      return printStatementSolveNode(node, path as FastPath<StatementSolveNode>, options, print);
    case 'Statement.Switch':
      return printStatementSwitchNode(node, path as FastPath<StatementSwitchNode>, options, print);
    case 'Statement.Throw':
      return printStatementThrowNode(node, path as FastPath<StatementThrowNode>, options, print);
    case 'Statement.Try':
      return printStatementTryNode(node, path as FastPath<StatementTryNode>, options, print);
    case 'Statement.TryFinally':
      return printStatementTryFinallyNode(node, path as FastPath<StatementTryFinallyNode>, options, print);
    case 'Statement.VariableDeclaration':
      return printStatementVariableDeclarationNode(node, path as FastPath<StatementVariableDeclarationNode>, options, print);
    case 'Statement.Visit':
      return printStatementVisitNode(node, path as FastPath<StatementVisitNode>, options, print);
    case 'Statement.While':
      return printStatementWhileNode(node, path as FastPath<StatementWhileNode>, options, print);
    case 'Strategy.BottomUp':
      return printStrategyBottomUpNode(node, path as FastPath<StrategyBottomUpNode>, options, print);
    case 'Strategy.BottomUpBreak':
      return printStrategyBottomUpBreakNode(node, path as FastPath<StrategyBottomUpBreakNode>, options, print);
    case 'Strategy.Innermost':
      return printStrategyInnermostNode(node, path as FastPath<StrategyInnermostNode>, options, print);
    case 'Strategy.Outermost':
      return printStrategyOutermostNode(node, path as FastPath<StrategyOutermostNode>, options, print);
    case 'Strategy.TopDown':
      return printStrategyTopDownNode(node, path as FastPath<StrategyTopDownNode>, options, print);
    case 'Strategy.TopDownBreak':
      return printStrategyTopDownBreakNode(node, path as FastPath<StrategyTopDownBreakNode>, options, print);
    case 'StringCharacter.Lexical':
      return printStringCharacterLexicalNode(node, path as FastPath<StringCharacterLexicalNode>, options, print);
    case 'StringConstant.Lexical':
      return printStringConstantLexicalNode(node, path as FastPath<StringConstantLexicalNode>, options, print);
    case 'StringLiteral.Interpolated':
      return printStringLiteralInterpolatedNode(node, path as FastPath<StringLiteralInterpolatedNode>, options, print);
    case 'StringLiteral.NonInterpolated':
      return printStringLiteralNonInterpolatedNode(node, path as FastPath<StringLiteralNonInterpolatedNode>, options, print);
    case 'StringLiteral.Template':
      return printStringLiteralTemplateNode(node, path as FastPath<StringLiteralTemplateNode>, options, print);
    case 'StringMiddle.Interpolated':
      return printStringMiddleInterpolatedNode(node, path as FastPath<StringMiddleInterpolatedNode>, options, print);
    case 'StringMiddle.Mid':
      return printStringMiddleMidNode(node, path as FastPath<StringMiddleMidNode>, options, print);
    case 'StringMiddle.Template':
      return printStringMiddleTemplateNode(node, path as FastPath<StringMiddleTemplateNode>, options, print);
    case 'StringTail.MidInterpolated':
      return printStringTailMidInterpolatedNode(node, path as FastPath<StringTailMidInterpolatedNode>, options, print);
    case 'StringTail.MidTemplate':
      return printStringTailMidTemplateNode(node, path as FastPath<StringTailMidTemplateNode>, options, print);
    case 'StringTail.Post':
      return printStringTailPostNode(node, path as FastPath<StringTailPostNode>, options, print);
    case 'StringTemplate.DoWhile':
      return printStringTemplateDoWhileNode(node, path as FastPath<StringTemplateDoWhileNode>, options, print);
    case 'StringTemplate.For':
      return printStringTemplateForNode(node, path as FastPath<StringTemplateForNode>, options, print);
    case 'StringTemplate.IfThen':
      return printStringTemplateIfThenNode(node, path as FastPath<StringTemplateIfThenNode>, options, print);
    case 'StringTemplate.IfThenElse':
      return printStringTemplateIfThenElseNode(node, path as FastPath<StringTemplateIfThenElseNode>, options, print);
    case 'StringTemplate.While':
      return printStringTemplateWhileNode(node, path as FastPath<StringTemplateWhileNode>, options, print);
    case 'StructuredType.Default':
      return printStructuredTypeDefaultNode(node, path as FastPath<StructuredTypeDefaultNode>, options, print);
    case 'Sym.Alternative':
      return printSymAlternativeNode(node, path as FastPath<SymAlternativeNode>, options, print);
    case 'Sym.CaseInsensitiveLiteral':
      return printSymCaseInsensitiveLiteralNode(node, path as FastPath<SymCaseInsensitiveLiteralNode>, options, print);
    case 'Sym.CharacterClass':
      return printSymCharacterClassNode(node, path as FastPath<SymCharacterClassNode>, options, print);
    case 'Sym.Column':
      return printSymColumnNode(node, path as FastPath<SymColumnNode>, options, print);
    case 'Sym.Empty':
      return printSymEmptyNode(node, path as FastPath<SymEmptyNode>, options, print);
    case 'Sym.EndOfLine':
      return printSymEndOfLineNode(node, path as FastPath<SymEndOfLineNode>, options, print);
    case 'Sym.Except':
      return printSymExceptNode(node, path as FastPath<SymExceptNode>, options, print);
    case 'Sym.Follow':
      return printSymFollowNode(node, path as FastPath<SymFollowNode>, options, print);
    case 'Sym.Iter':
      return printSymIterNode(node, path as FastPath<SymIterNode>, options, print);
    case 'Sym.IterSep':
      return printSymIterSepNode(node, path as FastPath<SymIterSepNode>, options, print);
    case 'Sym.IterStar':
      return printSymIterStarNode(node, path as FastPath<SymIterStarNode>, options, print);
    case 'Sym.IterStarSep':
      return printSymIterStarSepNode(node, path as FastPath<SymIterStarSepNode>, options, print);
    case 'Sym.Labeled':
      return printSymLabeledNode(node, path as FastPath<SymLabeledNode>, options, print);
    case 'Sym.Literal':
      return printSymLiteralNode(node, path as FastPath<SymLiteralNode>, options, print);
    case 'Sym.Nonterminal':
      return printSymNonterminalNode(node, path as FastPath<SymNonterminalNode>, options, print);
    case 'Sym.NotFollow':
      return printSymNotFollowNode(node, path as FastPath<SymNotFollowNode>, options, print);
    case 'Sym.NotPrecede':
      return printSymNotPrecedeNode(node, path as FastPath<SymNotPrecedeNode>, options, print);
    case 'Sym.Optional':
      return printSymOptionalNode(node, path as FastPath<SymOptionalNode>, options, print);
    case 'Sym.Parameter':
      return printSymParameterNode(node, path as FastPath<SymParameterNode>, options, print);
    case 'Sym.Parametrized':
      return printSymParametrizedNode(node, path as FastPath<SymParametrizedNode>, options, print);
    case 'Sym.Precede':
      return printSymPrecedeNode(node, path as FastPath<SymPrecedeNode>, options, print);
    case 'Sym.Sequence':
      return printSymSequenceNode(node, path as FastPath<SymSequenceNode>, options, print);
    case 'Sym.Start':
      return printSymStartNode(node, path as FastPath<SymStartNode>, options, print);
    case 'Sym.StartOfLine':
      return printSymStartOfLineNode(node, path as FastPath<SymStartOfLineNode>, options, print);
    case 'Sym.Unequal':
      return printSymUnequalNode(node, path as FastPath<SymUnequalNode>, options, print);
    case 'SyntaxDefinition.Keyword':
      return printSyntaxDefinitionKeywordNode(node, path as FastPath<SyntaxDefinitionKeywordNode>, options, print);
    case 'SyntaxDefinition.Language':
      return printSyntaxDefinitionLanguageNode(node, path as FastPath<SyntaxDefinitionLanguageNode>, options, print);
    case 'SyntaxDefinition.Layout':
      return printSyntaxDefinitionLayoutNode(node, path as FastPath<SyntaxDefinitionLayoutNode>, options, print);
    case 'SyntaxDefinition.Lexical':
      return printSyntaxDefinitionLexicalNode(node, path as FastPath<SyntaxDefinitionLexicalNode>, options, print);
    case 'Tag.Default':
      return printTagDefaultNode(node, path as FastPath<TagDefaultNode>, options, print);
    case 'Tag.Empty':
      return printTagEmptyNode(node, path as FastPath<TagEmptyNode>, options, print);
    case 'Tag.Expression':
      return printTagExpressionNode(node, path as FastPath<TagExpressionNode>, options, print);
    case 'TagString.Lexical':
      return printTagStringLexicalNode(node, path as FastPath<TagStringLexicalNode>, options, print);
    case 'Tags.Default':
      return printTagsDefaultNode(node, path as FastPath<TagsDefaultNode>, options, print);
    case 'Target.Empty':
      return printTargetEmptyNode(node, path as FastPath<TargetEmptyNode>, options, print);
    case 'Target.Labeled':
      return printTargetLabeledNode(node, path as FastPath<TargetLabeledNode>, options, print);
    case 'TimePartNoTZ.Lexical':
      return printTimePartNoTZLexicalNode(node, path as FastPath<TimePartNoTZLexicalNode>, options, print);
    case 'TimeZonePart.Lexical':
      return printTimeZonePartLexicalNode(node, path as FastPath<TimeZonePartLexicalNode>, options, print);
    case 'Toplevel.GivenVisibility':
      return printToplevelGivenVisibilityNode(node, path as FastPath<ToplevelGivenVisibilityNode>, options, print);
    case 'Type.Basic':
      return printTypeBasicNode(node, path as FastPath<TypeBasicNode>, options, print);
    case 'Type.Bracket':
      return printTypeBracketNode(node, path as FastPath<TypeBracketNode>, options, print);
    case 'Type.Function':
      return printTypeFunctionNode(node, path as FastPath<TypeFunctionNode>, options, print);
    case 'Type.Selector':
      return printTypeSelectorNode(node, path as FastPath<TypeSelectorNode>, options, print);
    case 'Type.Structured':
      return printTypeStructuredNode(node, path as FastPath<TypeStructuredNode>, options, print);
    case 'Type.Symbol':
      return printTypeSymbolNode(node, path as FastPath<TypeSymbolNode>, options, print);
    case 'Type.User':
      return printTypeUserNode(node, path as FastPath<TypeUserNode>, options, print);
    case 'Type.Variable':
      return printTypeVariableNode(node, path as FastPath<TypeVariableNode>, options, print);
    case 'TypeArg.Default':
      return printTypeArgDefaultNode(node, path as FastPath<TypeArgDefaultNode>, options, print);
    case 'TypeArg.Named':
      return printTypeArgNamedNode(node, path as FastPath<TypeArgNamedNode>, options, print);
    case 'TypeVar.Bounded':
      return printTypeVarBoundedNode(node, path as FastPath<TypeVarBoundedNode>, options, print);
    case 'TypeVar.Free':
      return printTypeVarFreeNode(node, path as FastPath<TypeVarFreeNode>, options, print);
    case 'URLChars.Lexical':
      return printURLCharsLexicalNode(node, path as FastPath<URLCharsLexicalNode>, options, print);
    case 'UnicodeEscape.Lexical':
      return printUnicodeEscapeLexicalNode(node, path as FastPath<UnicodeEscapeLexicalNode>, options, print);
    case 'UserType.Name':
      return printUserTypeNameNode(node, path as FastPath<UserTypeNameNode>, options, print);
    case 'UserType.Parametric':
      return printUserTypeParametricNode(node, path as FastPath<UserTypeParametricNode>, options, print);
    case 'Variable.Initialized':
      return printVariableInitializedNode(node, path as FastPath<VariableInitializedNode>, options, print);
    case 'Variable.UnInitialized':
      return printVariableUnInitializedNode(node, path as FastPath<VariableUnInitializedNode>, options, print);
    case 'Variant.NAryConstructor':
      return printVariantNAryConstructorNode(node, path as FastPath<VariantNAryConstructorNode>, options, print);
    case 'Visibility.Default':
      return printVisibilityDefaultNode(node, path as FastPath<VisibilityDefaultNode>, options, print);
    case 'Visibility.Private':
      return printVisibilityPrivateNode(node, path as FastPath<VisibilityPrivateNode>, options, print);
    case 'Visibility.Public':
      return printVisibilityPublicNode(node, path as FastPath<VisibilityPublicNode>, options, print);
    case 'Visit.DefaultStrategy':
      return printVisitDefaultStrategyNode(node, path as FastPath<VisitDefaultStrategyNode>, options, print);
    case 'Visit.GivenStrategy':
      return printVisitGivenStrategyNode(node, path as FastPath<VisitGivenStrategyNode>, options, print);
  }
}
