// This file is automatically generated by running 'yarn generate:printer'

import { Doc, FastPath, ParserOptions } from 'prettier';
import { printAssignableAnnotation, printAssignableBracket, printAssignableConstructor, printAssignableFieldAccess, printAssignableIfDefinedOrDefault, printAssignableSlice, printAssignableSliceStep, printAssignableSubscript, printAssignableTuple, printAssignableVariable } from './printers/assignable';
import { printAssignmentAddition, printAssignmentAppend, printAssignmentDefault, printAssignmentDivision, printAssignmentIfDefined, printAssignmentIntersection, printAssignmentProduct, printAssignmentSubtraction } from './printers/assignment';
import { printAssocAssociative, printAssocLeft, printAssocNonAssociative, printAssocRight } from './printers/assoc';
import { printBackslashLexical } from './printers/backslash';
import { printBasicTypeBag, printBasicTypeBool, printBasicTypeDateTime, printBasicTypeInt, printBasicTypeList, printBasicTypeListRelation, printBasicTypeLoc, printBasicTypeMap, printBasicTypeNode, printBasicTypeNum, printBasicTypeRational, printBasicTypeReal, printBasicTypeRelation, printBasicTypeSet, printBasicTypeString, printBasicTypeTuple, printBasicTypeType, printBasicTypeValue, printBasicTypeVoid } from './printers/basic-type';
import { printBodyToplevels } from './printers/body';
import { printBooleanLiteralLexical } from './printers/boolean-literal';
import { printBoundDefault, printBoundEmpty } from './printers/bound';
import { printCaseDefault, printCasePatternWithAction } from './printers/case';
import { printCaseInsensitiveStringConstantLexical } from './printers/case-insensitive-string-constant';
import { printCatchBinding, printCatchDefault } from './printers/catch';
import { printCharLexical } from './printers/char';
import { printClassBracket, printClassComplement, printClassDifference, printClassIntersection, printClassSimpleCharclass, printClassUnion } from './printers/class';
import { printCommandDeclaration, printCommandExpression, printCommandImport, printCommandShell, printCommandStatement } from './printers/command';
import { printCommandsCommandlist } from './printers/commands';
import { printCommentLexical } from './printers/comment';
import { printCommonKeywordParametersAbsent, printCommonKeywordParametersPresent } from './printers/common-keyword-parameters';
import { printComprehensionList, printComprehensionMap, printComprehensionSet } from './printers/comprehension';
import { printConcreteLexical } from './printers/concrete';
import { printConcreteHoleOne } from './printers/concrete-hole';
import { printConcretePartLexical } from './printers/concrete-part';
import { printDataTargetEmpty, printDataTargetLabeled } from './printers/data-target';
import { printDataTypeSelectorSelector } from './printers/data-type-selector';
import { printDateAndTimeLexical } from './printers/date-and-time';
import { printDatePartLexical } from './printers/date-part';
import { printDateTimeLiteralDateAndTimeLiteral, printDateTimeLiteralDateLiteral, printDateTimeLiteralTimeLiteral } from './printers/date-time-literal';
import { printDecimalIntegerLiteralLexical } from './printers/decimal-integer-literal';
import { printDeclarationAlias, printDeclarationAnnotation, printDeclarationData, printDeclarationDataAbstract, printDeclarationFunction, printDeclarationTag, printDeclarationVariable } from './printers/declaration';
import { printDeclaratorDefault } from './printers/declarator';
import { printEvalCommandDeclaration, printEvalCommandImport, printEvalCommandOutput, printEvalCommandStatement } from './printers/eval-command';
import { printExpressionAddition, printExpressionAll, printExpressionAnd, printExpressionAnti, printExpressionAny, printExpressionAppendAfter, printExpressionAsType, printExpressionBracket, printExpressionCallOrTree, printExpressionClosure, printExpressionComposition, printExpressionComprehension, printExpressionConcrete, printExpressionDescendant, printExpressionDivision, printExpressionEnumerator, printExpressionEquals, printExpressionEquivalence, printExpressionFieldAccess, printExpressionFieldProject, printExpressionFieldUpdate, printExpressionGetAnnotation, printExpressionGreaterThan, printExpressionGreaterThanOrEq, printExpressionHas, printExpressionIfDefinedOtherwise, printExpressionIfThenElse, printExpressionImplication, printExpressionIn, printExpressionInsertBefore, printExpressionIntersection, printExpressionIs, printExpressionIsDefined, printExpressionIt, printExpressionJoin, printExpressionLessThan, printExpressionLessThanOrEq, printExpressionList, printExpressionLiteral, printExpressionMap, printExpressionMatch, printExpressionModulo, printExpressionMultiVariable, printExpressionNegation, printExpressionNegative, printExpressionNoMatch, printExpressionNonEmptyBlock, printExpressionNonEquals, printExpressionNotIn, printExpressionOr, printExpressionProduct, printExpressionQualifiedName, printExpressionRange, printExpressionReducer, printExpressionReifiedType, printExpressionReifyType, printExpressionRemainder, printExpressionSet, printExpressionSetAnnotation, printExpressionSlice, printExpressionSliceStep, printExpressionSplice, printExpressionSplicePlus, printExpressionStepRange, printExpressionSubscript, printExpressionSubtraction, printExpressionTransitiveClosure, printExpressionTransitiveReflexiveClosure, printExpressionTuple, printExpressionTypedVariable, printExpressionTypedVariableBecomes, printExpressionVariableBecomes, printExpressionVisit, printExpressionVoidClosure } from './printers/expression';
import { printFieldIndex, printFieldName } from './printers/field';
import { printFormalsDefault } from './printers/formals';
import { printFunctionBodyDefault } from './printers/function-body';
import { printFunctionDeclarationAbstract, printFunctionDeclarationConditional, printFunctionDeclarationDefault, printFunctionDeclarationExpression } from './printers/function-declaration';
import { printFunctionModifierDefault, printFunctionModifierJava, printFunctionModifierTest } from './printers/function-modifier';
import { printFunctionModifiersModifierlist } from './printers/function-modifiers';
import { printFunctionTypeTypeArguments } from './printers/function-type';
import { printHeaderDefault, printHeaderParameters } from './printers/header';
import { printHexIntegerLiteralLexical } from './printers/hex-integer-literal';
import { printImportDefault, printImportExtend, printImportExternal, printImportSyntax } from './printers/import';
import { printImportedModuleActuals, printImportedModuleActualsRenaming, printImportedModuleDefault, printImportedModuleRenamings } from './printers/imported-module';
import { printIntegerLiteralDecimalIntegerLiteral, printIntegerLiteralHexIntegerLiteral, printIntegerLiteralOctalIntegerLiteral } from './printers/integer-literal';
import { printJustDateLexical } from './printers/just-date';
import { printJustTimeLexical } from './printers/just-time';
import { printKeywordArgument_ExpressionDefault } from './printers/keyword-argument-expression';
import { printKeywordArguments_ExpressionDefault, printKeywordArguments_ExpressionNone } from './printers/keyword-arguments-expression';
import { printKeywordFormalDefault } from './printers/keyword-formal';
import { printKeywordFormalsDefault, printKeywordFormalsNone } from './printers/keyword-formals';
import { printKindAlias, printKindAll, printKindAnno, printKindData, printKindFunction, printKindModule, printKindTag, printKindVariable, printKindView } from './printers/kind';
import { printLAYOUTLexical } from './printers/layout';
import { printLabelDefault, printLabelEmpty } from './printers/label';
import { printLiteralBoolean, printLiteralDateTime, printLiteralInteger, printLiteralLocation, printLiteralRational, printLiteralReal, printLiteralRegExp, printLiteralString } from './printers/literal';
import { printLocalVariableDeclarationDefault, printLocalVariableDeclarationDynamic } from './printers/local-variable-declaration';
import { printLocationLiteralDefault } from './printers/location-literal';
import { printMapping_ExpressionDefault } from './printers/mapping-expression';
import { printMidPathCharsLexical } from './printers/mid-path-chars';
import { printMidProtocolCharsLexical } from './printers/mid-protocol-chars';
import { printMidStringCharsLexical } from './printers/mid-string-chars';
import { printModuleDefault } from './printers/module';
import { printModuleActualsDefault } from './printers/module-actuals';
import { printModuleParametersDefault } from './printers/module-parameters';
import { printNameLexical } from './printers/name';
import { printNamedBackslashLexical } from './printers/named-backslash';
import { printNamedRegExpLexical } from './printers/named-reg-exp';
import { printNonterminalLexical } from './printers/nonterminal';
import { printNonterminalLabelLexical } from './printers/nonterminal-label';
import { printOctalIntegerLiteralLexical } from './printers/octal-integer-literal';
import { printOptionalCommaLexical } from './printers/optional-comma';
import { printOptionalExpressionExpression, printOptionalExpressionNoExpression } from './printers/optional-expression';
import { printOutputLexical } from './printers/output';
import { printParametersDefault, printParametersVarArgs } from './printers/parameters';
import { printPathCharsLexical } from './printers/path-chars';
import { printPathPartInterpolated, printPathPartNonInterpolated } from './printers/path-part';
import { printPathTailMid, printPathTailPost } from './printers/path-tail';
import { printPatternWithActionArbitrary, printPatternWithActionReplacing } from './printers/pattern-with-action';
import { printPostPathCharsLexical } from './printers/post-path-chars';
import { printPostProtocolCharsLexical } from './printers/post-protocol-chars';
import { printPostStringCharsLexical } from './printers/post-string-chars';
import { printPrePathCharsLexical } from './printers/pre-path-chars';
import { printPreProtocolCharsLexical } from './printers/pre-protocol-chars';
import { printPreStringCharsLexical } from './printers/pre-string-chars';
import { printProdAll, printProdAssociativityGroup, printProdFirst, printProdLabeled, printProdReference, printProdUnlabeled } from './printers/prod';
import { printProdModifierAssociativity, printProdModifierBracket, printProdModifierTag } from './printers/prod-modifier';
import { printProtocolCharsLexical } from './printers/protocol-chars';
import { printProtocolPartInterpolated, printProtocolPartNonInterpolated } from './printers/protocol-part';
import { printProtocolTailMid, printProtocolTailPost } from './printers/protocol-tail';
import { printQualifiedNameDefault } from './printers/qualified-name';
import { printRangeCharacter, printRangeFromTo } from './printers/range';
import { printRationalLiteralLexical } from './printers/rational-literal';
import { printRealLiteralLexical } from './printers/real-literal';
import { printRegExpLexical } from './printers/reg-exp';
import { printRegExpLiteralLexical } from './printers/reg-exp-literal';
import { printRegExpModifierLexical } from './printers/reg-exp-modifier';
import { printRenamingDefault } from './printers/renaming';
import { printRenamingsDefault } from './printers/renamings';
import { printReplacementConditional, printReplacementUnconditional } from './printers/replacement';
import { printShellCommandClear, printShellCommandEdit, printShellCommandHelp, printShellCommandHistory, printShellCommandListDeclarations, printShellCommandListModules, printShellCommandQuit, printShellCommandSetOption, printShellCommandTest, printShellCommandUndeclare, printShellCommandUnimport } from './printers/shell-command';
import { printSignatureNoThrows, printSignatureWithThrows } from './printers/signature';
import { printStartAbsent, printStartPresent } from './printers/start';
import { printStatementAppend, printStatementAssert, printStatementAssertWithMessage, printStatementAssignment, printStatementBreak, printStatementContinue, printStatementDoWhile, printStatementEmptyStatement, printStatementExpression, printStatementFail, printStatementFilter, printStatementFor, printStatementFunctionDeclaration, printStatementGlobalDirective, printStatementIfThen, printStatementIfThenElse, printStatementInsert, printStatementNonEmptyBlock, printStatementReturn, printStatementSolve, printStatementSwitch, printStatementThrow, printStatementTry, printStatementTryFinally, printStatementVariableDeclaration, printStatementVisit, printStatementWhile } from './printers/statement';
import { printStrategyBottomUp, printStrategyBottomUpBreak, printStrategyInnermost, printStrategyOutermost, printStrategyTopDown, printStrategyTopDownBreak } from './printers/strategy';
import { printStringCharacterLexical } from './printers/string-character';
import { printStringConstantLexical } from './printers/string-constant';
import { printStringLiteralInterpolated, printStringLiteralNonInterpolated, printStringLiteralTemplate } from './printers/string-literal';
import { printStringMiddleInterpolated, printStringMiddleMid, printStringMiddleTemplate } from './printers/string-middle';
import { printStringTailMidInterpolated, printStringTailMidTemplate, printStringTailPost } from './printers/string-tail';
import { printStringTemplateDoWhile, printStringTemplateFor, printStringTemplateIfThen, printStringTemplateIfThenElse, printStringTemplateWhile } from './printers/string-template';
import { printStructuredTypeDefault } from './printers/structured-type';
import { printSymAlternative, printSymCaseInsensitiveLiteral, printSymCharacterClass, printSymColumn, printSymEmpty, printSymEndOfLine, printSymExcept, printSymFollow, printSymIter, printSymIterSep, printSymIterStar, printSymIterStarSep, printSymLabeled, printSymLiteral, printSymNonterminal, printSymNotFollow, printSymNotPrecede, printSymOptional, printSymParameter, printSymParametrized, printSymPrecede, printSymSequence, printSymStart, printSymStartOfLine, printSymUnequal } from './printers/sym';
import { printSyntaxDefinitionKeyword, printSyntaxDefinitionLanguage, printSyntaxDefinitionLayout, printSyntaxDefinitionLexical } from './printers/syntax-definition';
import { printTagDefault, printTagEmpty, printTagExpression } from './printers/tag';
import { printTagStringLexical } from './printers/tag-string';
import { printTagsDefault } from './printers/tags';
import { printTargetEmpty, printTargetLabeled } from './printers/target';
import { printTimePartNoTZLexical } from './printers/time-part-no-tz';
import { printTimeZonePartLexical } from './printers/time-zone-part';
import { printToplevelGivenVisibility } from './printers/toplevel';
import { printTypeBasic, printTypeBracket, printTypeFunction, printTypeSelector, printTypeStructured, printTypeSymbol, printTypeUser, printTypeVariable } from './printers/type';
import { printTypeArgDefault, printTypeArgNamed } from './printers/type-arg';
import { printTypeVarBounded, printTypeVarFree } from './printers/type-var';
import { printURLCharsLexical } from './printers/url-chars';
import { printUnicodeEscapeLexical } from './printers/unicode-escape';
import { printUserTypeName, printUserTypeParametric } from './printers/user-type';
import { printVariableInitialized, printVariableUnInitialized } from './printers/variable';
import { printVariantNAryConstructor } from './printers/variant';
import { printVisibilityDefault, printVisibilityPrivate, printVisibilityPublic } from './printers/visibility';
import { printVisitDefaultStrategy, printVisitGivenStrategy } from './printers/visit';

export function print(path: FastPath<ASTNode>, options: ParserOptions, print: (path: FastPath<ASTNode>) => Doc): Doc {
  switch (path.getValue()._type) {
    case 'Assignable.Annotation':
      return printAssignableAnnotation(path as FastPath<AssignableAnnotationNode>, options, print);
    case 'Assignable.Bracket':
      return printAssignableBracket(path as FastPath<AssignableBracketNode>, options, print);
    case 'Assignable.Constructor':
      return printAssignableConstructor(path as FastPath<AssignableConstructorNode>, options, print);
    case 'Assignable.FieldAccess':
      return printAssignableFieldAccess(path as FastPath<AssignableFieldAccessNode>, options, print);
    case 'Assignable.IfDefinedOrDefault':
      return printAssignableIfDefinedOrDefault(path as FastPath<AssignableIfDefinedOrDefaultNode>, options, print);
    case 'Assignable.Slice':
      return printAssignableSlice(path as FastPath<AssignableSliceNode>, options, print);
    case 'Assignable.SliceStep':
      return printAssignableSliceStep(path as FastPath<AssignableSliceStepNode>, options, print);
    case 'Assignable.Subscript':
      return printAssignableSubscript(path as FastPath<AssignableSubscriptNode>, options, print);
    case 'Assignable.Tuple':
      return printAssignableTuple(path as FastPath<AssignableTupleNode>, options, print);
    case 'Assignable.Variable':
      return printAssignableVariable(path as FastPath<AssignableVariableNode>, options, print);
    case 'Assignment.Addition':
      return printAssignmentAddition(path as FastPath<AssignmentAdditionNode>, options, print);
    case 'Assignment.Append':
      return printAssignmentAppend(path as FastPath<AssignmentAppendNode>, options, print);
    case 'Assignment.Default':
      return printAssignmentDefault(path as FastPath<AssignmentDefaultNode>, options, print);
    case 'Assignment.Division':
      return printAssignmentDivision(path as FastPath<AssignmentDivisionNode>, options, print);
    case 'Assignment.IfDefined':
      return printAssignmentIfDefined(path as FastPath<AssignmentIfDefinedNode>, options, print);
    case 'Assignment.Intersection':
      return printAssignmentIntersection(path as FastPath<AssignmentIntersectionNode>, options, print);
    case 'Assignment.Product':
      return printAssignmentProduct(path as FastPath<AssignmentProductNode>, options, print);
    case 'Assignment.Subtraction':
      return printAssignmentSubtraction(path as FastPath<AssignmentSubtractionNode>, options, print);
    case 'Assoc.Associative':
      return printAssocAssociative(path as FastPath<AssocAssociativeNode>, options, print);
    case 'Assoc.Left':
      return printAssocLeft(path as FastPath<AssocLeftNode>, options, print);
    case 'Assoc.NonAssociative':
      return printAssocNonAssociative(path as FastPath<AssocNonAssociativeNode>, options, print);
    case 'Assoc.Right':
      return printAssocRight(path as FastPath<AssocRightNode>, options, print);
    case 'Backslash.Lexical':
      return printBackslashLexical(path as FastPath<BackslashLexicalNode>, options, print);
    case 'BasicType.Bag':
      return printBasicTypeBag(path as FastPath<BasicTypeBagNode>, options, print);
    case 'BasicType.Bool':
      return printBasicTypeBool(path as FastPath<BasicTypeBoolNode>, options, print);
    case 'BasicType.DateTime':
      return printBasicTypeDateTime(path as FastPath<BasicTypeDateTimeNode>, options, print);
    case 'BasicType.Int':
      return printBasicTypeInt(path as FastPath<BasicTypeIntNode>, options, print);
    case 'BasicType.List':
      return printBasicTypeList(path as FastPath<BasicTypeListNode>, options, print);
    case 'BasicType.ListRelation':
      return printBasicTypeListRelation(path as FastPath<BasicTypeListRelationNode>, options, print);
    case 'BasicType.Loc':
      return printBasicTypeLoc(path as FastPath<BasicTypeLocNode>, options, print);
    case 'BasicType.Map':
      return printBasicTypeMap(path as FastPath<BasicTypeMapNode>, options, print);
    case 'BasicType.Node':
      return printBasicTypeNode(path as FastPath<BasicTypeNodeNode>, options, print);
    case 'BasicType.Num':
      return printBasicTypeNum(path as FastPath<BasicTypeNumNode>, options, print);
    case 'BasicType.Rational':
      return printBasicTypeRational(path as FastPath<BasicTypeRationalNode>, options, print);
    case 'BasicType.Real':
      return printBasicTypeReal(path as FastPath<BasicTypeRealNode>, options, print);
    case 'BasicType.Relation':
      return printBasicTypeRelation(path as FastPath<BasicTypeRelationNode>, options, print);
    case 'BasicType.Set':
      return printBasicTypeSet(path as FastPath<BasicTypeSetNode>, options, print);
    case 'BasicType.String':
      return printBasicTypeString(path as FastPath<BasicTypeStringNode>, options, print);
    case 'BasicType.Tuple':
      return printBasicTypeTuple(path as FastPath<BasicTypeTupleNode>, options, print);
    case 'BasicType.Type':
      return printBasicTypeType(path as FastPath<BasicTypeTypeNode>, options, print);
    case 'BasicType.Value':
      return printBasicTypeValue(path as FastPath<BasicTypeValueNode>, options, print);
    case 'BasicType.Void':
      return printBasicTypeVoid(path as FastPath<BasicTypeVoidNode>, options, print);
    case 'Body.Toplevels':
      return printBodyToplevels(path as FastPath<BodyToplevelsNode>, options, print);
    case 'BooleanLiteral.Lexical':
      return printBooleanLiteralLexical(path as FastPath<BooleanLiteralLexicalNode>, options, print);
    case 'Bound.Default':
      return printBoundDefault(path as FastPath<BoundDefaultNode>, options, print);
    case 'Bound.Empty':
      return printBoundEmpty(path as FastPath<BoundEmptyNode>, options, print);
    case 'Case.Default':
      return printCaseDefault(path as FastPath<CaseDefaultNode>, options, print);
    case 'Case.PatternWithAction':
      return printCasePatternWithAction(path as FastPath<CasePatternWithActionNode>, options, print);
    case 'CaseInsensitiveStringConstant.Lexical':
      return printCaseInsensitiveStringConstantLexical(path as FastPath<CaseInsensitiveStringConstantLexicalNode>, options, print);
    case 'Catch.Binding':
      return printCatchBinding(path as FastPath<CatchBindingNode>, options, print);
    case 'Catch.Default':
      return printCatchDefault(path as FastPath<CatchDefaultNode>, options, print);
    case 'Char.Lexical':
      return printCharLexical(path as FastPath<CharLexicalNode>, options, print);
    case 'Class.Bracket':
      return printClassBracket(path as FastPath<ClassBracketNode>, options, print);
    case 'Class.Complement':
      return printClassComplement(path as FastPath<ClassComplementNode>, options, print);
    case 'Class.Difference':
      return printClassDifference(path as FastPath<ClassDifferenceNode>, options, print);
    case 'Class.Intersection':
      return printClassIntersection(path as FastPath<ClassIntersectionNode>, options, print);
    case 'Class.SimpleCharclass':
      return printClassSimpleCharclass(path as FastPath<ClassSimpleCharclassNode>, options, print);
    case 'Class.Union':
      return printClassUnion(path as FastPath<ClassUnionNode>, options, print);
    case 'Command.Declaration':
      return printCommandDeclaration(path as FastPath<CommandDeclarationNode>, options, print);
    case 'Command.Expression':
      return printCommandExpression(path as FastPath<CommandExpressionNode>, options, print);
    case 'Command.Import':
      return printCommandImport(path as FastPath<CommandImportNode>, options, print);
    case 'Command.Shell':
      return printCommandShell(path as FastPath<CommandShellNode>, options, print);
    case 'Command.Statement':
      return printCommandStatement(path as FastPath<CommandStatementNode>, options, print);
    case 'Commands.Commandlist':
      return printCommandsCommandlist(path as FastPath<CommandsCommandlistNode>, options, print);
    case 'Comment.Lexical':
      return printCommentLexical(path as FastPath<CommentLexicalNode>, options, print);
    case 'CommonKeywordParameters.Absent':
      return printCommonKeywordParametersAbsent(path as FastPath<CommonKeywordParametersAbsentNode>, options, print);
    case 'CommonKeywordParameters.Present':
      return printCommonKeywordParametersPresent(path as FastPath<CommonKeywordParametersPresentNode>, options, print);
    case 'Comprehension.List':
      return printComprehensionList(path as FastPath<ComprehensionListNode>, options, print);
    case 'Comprehension.Map':
      return printComprehensionMap(path as FastPath<ComprehensionMapNode>, options, print);
    case 'Comprehension.Set':
      return printComprehensionSet(path as FastPath<ComprehensionSetNode>, options, print);
    case 'Concrete.Lexical':
      return printConcreteLexical(path as FastPath<ConcreteLexicalNode>, options, print);
    case 'ConcreteHole.One':
      return printConcreteHoleOne(path as FastPath<ConcreteHoleOneNode>, options, print);
    case 'ConcretePart.Lexical':
      return printConcretePartLexical(path as FastPath<ConcretePartLexicalNode>, options, print);
    case 'DataTarget.Empty':
      return printDataTargetEmpty(path as FastPath<DataTargetEmptyNode>, options, print);
    case 'DataTarget.Labeled':
      return printDataTargetLabeled(path as FastPath<DataTargetLabeledNode>, options, print);
    case 'DataTypeSelector.Selector':
      return printDataTypeSelectorSelector(path as FastPath<DataTypeSelectorSelectorNode>, options, print);
    case 'DateAndTime.Lexical':
      return printDateAndTimeLexical(path as FastPath<DateAndTimeLexicalNode>, options, print);
    case 'DatePart.Lexical':
      return printDatePartLexical(path as FastPath<DatePartLexicalNode>, options, print);
    case 'DateTimeLiteral.DateAndTimeLiteral':
      return printDateTimeLiteralDateAndTimeLiteral(path as FastPath<DateTimeLiteralDateAndTimeLiteralNode>, options, print);
    case 'DateTimeLiteral.DateLiteral':
      return printDateTimeLiteralDateLiteral(path as FastPath<DateTimeLiteralDateLiteralNode>, options, print);
    case 'DateTimeLiteral.TimeLiteral':
      return printDateTimeLiteralTimeLiteral(path as FastPath<DateTimeLiteralTimeLiteralNode>, options, print);
    case 'DecimalIntegerLiteral.Lexical':
      return printDecimalIntegerLiteralLexical(path as FastPath<DecimalIntegerLiteralLexicalNode>, options, print);
    case 'Declaration.Alias':
      return printDeclarationAlias(path as FastPath<DeclarationAliasNode>, options, print);
    case 'Declaration.Annotation':
      return printDeclarationAnnotation(path as FastPath<DeclarationAnnotationNode>, options, print);
    case 'Declaration.Data':
      return printDeclarationData(path as FastPath<DeclarationDataNode>, options, print);
    case 'Declaration.DataAbstract':
      return printDeclarationDataAbstract(path as FastPath<DeclarationDataAbstractNode>, options, print);
    case 'Declaration.Function':
      return printDeclarationFunction(path as FastPath<DeclarationFunctionNode>, options, print);
    case 'Declaration.Tag':
      return printDeclarationTag(path as FastPath<DeclarationTagNode>, options, print);
    case 'Declaration.Variable':
      return printDeclarationVariable(path as FastPath<DeclarationVariableNode>, options, print);
    case 'Declarator.Default':
      return printDeclaratorDefault(path as FastPath<DeclaratorDefaultNode>, options, print);
    case 'EvalCommand.Declaration':
      return printEvalCommandDeclaration(path as FastPath<EvalCommandDeclarationNode>, options, print);
    case 'EvalCommand.Import':
      return printEvalCommandImport(path as FastPath<EvalCommandImportNode>, options, print);
    case 'EvalCommand.Output':
      return printEvalCommandOutput(path as FastPath<EvalCommandOutputNode>, options, print);
    case 'EvalCommand.Statement':
      return printEvalCommandStatement(path as FastPath<EvalCommandStatementNode>, options, print);
    case 'Expression.Addition':
      return printExpressionAddition(path as FastPath<ExpressionAdditionNode>, options, print);
    case 'Expression.All':
      return printExpressionAll(path as FastPath<ExpressionAllNode>, options, print);
    case 'Expression.And':
      return printExpressionAnd(path as FastPath<ExpressionAndNode>, options, print);
    case 'Expression.Anti':
      return printExpressionAnti(path as FastPath<ExpressionAntiNode>, options, print);
    case 'Expression.Any':
      return printExpressionAny(path as FastPath<ExpressionAnyNode>, options, print);
    case 'Expression.AppendAfter':
      return printExpressionAppendAfter(path as FastPath<ExpressionAppendAfterNode>, options, print);
    case 'Expression.AsType':
      return printExpressionAsType(path as FastPath<ExpressionAsTypeNode>, options, print);
    case 'Expression.Bracket':
      return printExpressionBracket(path as FastPath<ExpressionBracketNode>, options, print);
    case 'Expression.CallOrTree':
      return printExpressionCallOrTree(path as FastPath<ExpressionCallOrTreeNode>, options, print);
    case 'Expression.Closure':
      return printExpressionClosure(path as FastPath<ExpressionClosureNode>, options, print);
    case 'Expression.Composition':
      return printExpressionComposition(path as FastPath<ExpressionCompositionNode>, options, print);
    case 'Expression.Comprehension':
      return printExpressionComprehension(path as FastPath<ExpressionComprehensionNode>, options, print);
    case 'Expression.Concrete':
      return printExpressionConcrete(path as FastPath<ExpressionConcreteNode>, options, print);
    case 'Expression.Descendant':
      return printExpressionDescendant(path as FastPath<ExpressionDescendantNode>, options, print);
    case 'Expression.Division':
      return printExpressionDivision(path as FastPath<ExpressionDivisionNode>, options, print);
    case 'Expression.Enumerator':
      return printExpressionEnumerator(path as FastPath<ExpressionEnumeratorNode>, options, print);
    case 'Expression.Equals':
      return printExpressionEquals(path as FastPath<ExpressionEqualsNode>, options, print);
    case 'Expression.Equivalence':
      return printExpressionEquivalence(path as FastPath<ExpressionEquivalenceNode>, options, print);
    case 'Expression.FieldAccess':
      return printExpressionFieldAccess(path as FastPath<ExpressionFieldAccessNode>, options, print);
    case 'Expression.FieldProject':
      return printExpressionFieldProject(path as FastPath<ExpressionFieldProjectNode>, options, print);
    case 'Expression.FieldUpdate':
      return printExpressionFieldUpdate(path as FastPath<ExpressionFieldUpdateNode>, options, print);
    case 'Expression.GetAnnotation':
      return printExpressionGetAnnotation(path as FastPath<ExpressionGetAnnotationNode>, options, print);
    case 'Expression.GreaterThan':
      return printExpressionGreaterThan(path as FastPath<ExpressionGreaterThanNode>, options, print);
    case 'Expression.GreaterThanOrEq':
      return printExpressionGreaterThanOrEq(path as FastPath<ExpressionGreaterThanOrEqNode>, options, print);
    case 'Expression.Has':
      return printExpressionHas(path as FastPath<ExpressionHasNode>, options, print);
    case 'Expression.IfDefinedOtherwise':
      return printExpressionIfDefinedOtherwise(path as FastPath<ExpressionIfDefinedOtherwiseNode>, options, print);
    case 'Expression.IfThenElse':
      return printExpressionIfThenElse(path as FastPath<ExpressionIfThenElseNode>, options, print);
    case 'Expression.Implication':
      return printExpressionImplication(path as FastPath<ExpressionImplicationNode>, options, print);
    case 'Expression.In':
      return printExpressionIn(path as FastPath<ExpressionInNode>, options, print);
    case 'Expression.InsertBefore':
      return printExpressionInsertBefore(path as FastPath<ExpressionInsertBeforeNode>, options, print);
    case 'Expression.Intersection':
      return printExpressionIntersection(path as FastPath<ExpressionIntersectionNode>, options, print);
    case 'Expression.Is':
      return printExpressionIs(path as FastPath<ExpressionIsNode>, options, print);
    case 'Expression.IsDefined':
      return printExpressionIsDefined(path as FastPath<ExpressionIsDefinedNode>, options, print);
    case 'Expression.It':
      return printExpressionIt(path as FastPath<ExpressionItNode>, options, print);
    case 'Expression.Join':
      return printExpressionJoin(path as FastPath<ExpressionJoinNode>, options, print);
    case 'Expression.LessThan':
      return printExpressionLessThan(path as FastPath<ExpressionLessThanNode>, options, print);
    case 'Expression.LessThanOrEq':
      return printExpressionLessThanOrEq(path as FastPath<ExpressionLessThanOrEqNode>, options, print);
    case 'Expression.List':
      return printExpressionList(path as FastPath<ExpressionListNode>, options, print);
    case 'Expression.Literal':
      return printExpressionLiteral(path as FastPath<ExpressionLiteralNode>, options, print);
    case 'Expression.Map':
      return printExpressionMap(path as FastPath<ExpressionMapNode>, options, print);
    case 'Expression.Match':
      return printExpressionMatch(path as FastPath<ExpressionMatchNode>, options, print);
    case 'Expression.Modulo':
      return printExpressionModulo(path as FastPath<ExpressionModuloNode>, options, print);
    case 'Expression.MultiVariable':
      return printExpressionMultiVariable(path as FastPath<ExpressionMultiVariableNode>, options, print);
    case 'Expression.Negation':
      return printExpressionNegation(path as FastPath<ExpressionNegationNode>, options, print);
    case 'Expression.Negative':
      return printExpressionNegative(path as FastPath<ExpressionNegativeNode>, options, print);
    case 'Expression.NoMatch':
      return printExpressionNoMatch(path as FastPath<ExpressionNoMatchNode>, options, print);
    case 'Expression.NonEmptyBlock':
      return printExpressionNonEmptyBlock(path as FastPath<ExpressionNonEmptyBlockNode>, options, print);
    case 'Expression.NonEquals':
      return printExpressionNonEquals(path as FastPath<ExpressionNonEqualsNode>, options, print);
    case 'Expression.NotIn':
      return printExpressionNotIn(path as FastPath<ExpressionNotInNode>, options, print);
    case 'Expression.Or':
      return printExpressionOr(path as FastPath<ExpressionOrNode>, options, print);
    case 'Expression.Product':
      return printExpressionProduct(path as FastPath<ExpressionProductNode>, options, print);
    case 'Expression.QualifiedName':
      return printExpressionQualifiedName(path as FastPath<ExpressionQualifiedNameNode>, options, print);
    case 'Expression.Range':
      return printExpressionRange(path as FastPath<ExpressionRangeNode>, options, print);
    case 'Expression.Reducer':
      return printExpressionReducer(path as FastPath<ExpressionReducerNode>, options, print);
    case 'Expression.ReifiedType':
      return printExpressionReifiedType(path as FastPath<ExpressionReifiedTypeNode>, options, print);
    case 'Expression.ReifyType':
      return printExpressionReifyType(path as FastPath<ExpressionReifyTypeNode>, options, print);
    case 'Expression.Remainder':
      return printExpressionRemainder(path as FastPath<ExpressionRemainderNode>, options, print);
    case 'Expression.Set':
      return printExpressionSet(path as FastPath<ExpressionSetNode>, options, print);
    case 'Expression.SetAnnotation':
      return printExpressionSetAnnotation(path as FastPath<ExpressionSetAnnotationNode>, options, print);
    case 'Expression.Slice':
      return printExpressionSlice(path as FastPath<ExpressionSliceNode>, options, print);
    case 'Expression.SliceStep':
      return printExpressionSliceStep(path as FastPath<ExpressionSliceStepNode>, options, print);
    case 'Expression.Splice':
      return printExpressionSplice(path as FastPath<ExpressionSpliceNode>, options, print);
    case 'Expression.SplicePlus':
      return printExpressionSplicePlus(path as FastPath<ExpressionSplicePlusNode>, options, print);
    case 'Expression.StepRange':
      return printExpressionStepRange(path as FastPath<ExpressionStepRangeNode>, options, print);
    case 'Expression.Subscript':
      return printExpressionSubscript(path as FastPath<ExpressionSubscriptNode>, options, print);
    case 'Expression.Subtraction':
      return printExpressionSubtraction(path as FastPath<ExpressionSubtractionNode>, options, print);
    case 'Expression.TransitiveClosure':
      return printExpressionTransitiveClosure(path as FastPath<ExpressionTransitiveClosureNode>, options, print);
    case 'Expression.TransitiveReflexiveClosure':
      return printExpressionTransitiveReflexiveClosure(path as FastPath<ExpressionTransitiveReflexiveClosureNode>, options, print);
    case 'Expression.Tuple':
      return printExpressionTuple(path as FastPath<ExpressionTupleNode>, options, print);
    case 'Expression.TypedVariable':
      return printExpressionTypedVariable(path as FastPath<ExpressionTypedVariableNode>, options, print);
    case 'Expression.TypedVariableBecomes':
      return printExpressionTypedVariableBecomes(path as FastPath<ExpressionTypedVariableBecomesNode>, options, print);
    case 'Expression.VariableBecomes':
      return printExpressionVariableBecomes(path as FastPath<ExpressionVariableBecomesNode>, options, print);
    case 'Expression.Visit':
      return printExpressionVisit(path as FastPath<ExpressionVisitNode>, options, print);
    case 'Expression.VoidClosure':
      return printExpressionVoidClosure(path as FastPath<ExpressionVoidClosureNode>, options, print);
    case 'Field.Index':
      return printFieldIndex(path as FastPath<FieldIndexNode>, options, print);
    case 'Field.Name':
      return printFieldName(path as FastPath<FieldNameNode>, options, print);
    case 'Formals.Default':
      return printFormalsDefault(path as FastPath<FormalsDefaultNode>, options, print);
    case 'FunctionBody.Default':
      return printFunctionBodyDefault(path as FastPath<FunctionBodyDefaultNode>, options, print);
    case 'FunctionDeclaration.Abstract':
      return printFunctionDeclarationAbstract(path as FastPath<FunctionDeclarationAbstractNode>, options, print);
    case 'FunctionDeclaration.Conditional':
      return printFunctionDeclarationConditional(path as FastPath<FunctionDeclarationConditionalNode>, options, print);
    case 'FunctionDeclaration.Default':
      return printFunctionDeclarationDefault(path as FastPath<FunctionDeclarationDefaultNode>, options, print);
    case 'FunctionDeclaration.Expression':
      return printFunctionDeclarationExpression(path as FastPath<FunctionDeclarationExpressionNode>, options, print);
    case 'FunctionModifier.Default':
      return printFunctionModifierDefault(path as FastPath<FunctionModifierDefaultNode>, options, print);
    case 'FunctionModifier.Java':
      return printFunctionModifierJava(path as FastPath<FunctionModifierJavaNode>, options, print);
    case 'FunctionModifier.Test':
      return printFunctionModifierTest(path as FastPath<FunctionModifierTestNode>, options, print);
    case 'FunctionModifiers.Modifierlist':
      return printFunctionModifiersModifierlist(path as FastPath<FunctionModifiersModifierlistNode>, options, print);
    case 'FunctionType.TypeArguments':
      return printFunctionTypeTypeArguments(path as FastPath<FunctionTypeTypeArgumentsNode>, options, print);
    case 'Header.Default':
      return printHeaderDefault(path as FastPath<HeaderDefaultNode>, options, print);
    case 'Header.Parameters':
      return printHeaderParameters(path as FastPath<HeaderParametersNode>, options, print);
    case 'HexIntegerLiteral.Lexical':
      return printHexIntegerLiteralLexical(path as FastPath<HexIntegerLiteralLexicalNode>, options, print);
    case 'Import.Default':
      return printImportDefault(path as FastPath<ImportDefaultNode>, options, print);
    case 'Import.Extend':
      return printImportExtend(path as FastPath<ImportExtendNode>, options, print);
    case 'Import.External':
      return printImportExternal(path as FastPath<ImportExternalNode>, options, print);
    case 'Import.Syntax':
      return printImportSyntax(path as FastPath<ImportSyntaxNode>, options, print);
    case 'ImportedModule.Actuals':
      return printImportedModuleActuals(path as FastPath<ImportedModuleActualsNode>, options, print);
    case 'ImportedModule.ActualsRenaming':
      return printImportedModuleActualsRenaming(path as FastPath<ImportedModuleActualsRenamingNode>, options, print);
    case 'ImportedModule.Default':
      return printImportedModuleDefault(path as FastPath<ImportedModuleDefaultNode>, options, print);
    case 'ImportedModule.Renamings':
      return printImportedModuleRenamings(path as FastPath<ImportedModuleRenamingsNode>, options, print);
    case 'IntegerLiteral.DecimalIntegerLiteral':
      return printIntegerLiteralDecimalIntegerLiteral(path as FastPath<IntegerLiteralDecimalIntegerLiteralNode>, options, print);
    case 'IntegerLiteral.HexIntegerLiteral':
      return printIntegerLiteralHexIntegerLiteral(path as FastPath<IntegerLiteralHexIntegerLiteralNode>, options, print);
    case 'IntegerLiteral.OctalIntegerLiteral':
      return printIntegerLiteralOctalIntegerLiteral(path as FastPath<IntegerLiteralOctalIntegerLiteralNode>, options, print);
    case 'JustDate.Lexical':
      return printJustDateLexical(path as FastPath<JustDateLexicalNode>, options, print);
    case 'JustTime.Lexical':
      return printJustTimeLexical(path as FastPath<JustTimeLexicalNode>, options, print);
    case 'KeywordArgument_Expression.Default':
      return printKeywordArgument_ExpressionDefault(path as FastPath<KeywordArgument_ExpressionDefaultNode>, options, print);
    case 'KeywordArguments_Expression.Default':
      return printKeywordArguments_ExpressionDefault(path as FastPath<KeywordArguments_ExpressionDefaultNode>, options, print);
    case 'KeywordArguments_Expression.None':
      return printKeywordArguments_ExpressionNone(path as FastPath<KeywordArguments_ExpressionNoneNode>, options, print);
    case 'KeywordFormal.Default':
      return printKeywordFormalDefault(path as FastPath<KeywordFormalDefaultNode>, options, print);
    case 'KeywordFormals.Default':
      return printKeywordFormalsDefault(path as FastPath<KeywordFormalsDefaultNode>, options, print);
    case 'KeywordFormals.None':
      return printKeywordFormalsNone(path as FastPath<KeywordFormalsNoneNode>, options, print);
    case 'Kind.Alias':
      return printKindAlias(path as FastPath<KindAliasNode>, options, print);
    case 'Kind.All':
      return printKindAll(path as FastPath<KindAllNode>, options, print);
    case 'Kind.Anno':
      return printKindAnno(path as FastPath<KindAnnoNode>, options, print);
    case 'Kind.Data':
      return printKindData(path as FastPath<KindDataNode>, options, print);
    case 'Kind.Function':
      return printKindFunction(path as FastPath<KindFunctionNode>, options, print);
    case 'Kind.Module':
      return printKindModule(path as FastPath<KindModuleNode>, options, print);
    case 'Kind.Tag':
      return printKindTag(path as FastPath<KindTagNode>, options, print);
    case 'Kind.Variable':
      return printKindVariable(path as FastPath<KindVariableNode>, options, print);
    case 'Kind.View':
      return printKindView(path as FastPath<KindViewNode>, options, print);
    case 'LAYOUT.Lexical':
      return printLAYOUTLexical(path as FastPath<LAYOUTLexicalNode>, options, print);
    case 'Label.Default':
      return printLabelDefault(path as FastPath<LabelDefaultNode>, options, print);
    case 'Label.Empty':
      return printLabelEmpty(path as FastPath<LabelEmptyNode>, options, print);
    case 'Literal.Boolean':
      return printLiteralBoolean(path as FastPath<LiteralBooleanNode>, options, print);
    case 'Literal.DateTime':
      return printLiteralDateTime(path as FastPath<LiteralDateTimeNode>, options, print);
    case 'Literal.Integer':
      return printLiteralInteger(path as FastPath<LiteralIntegerNode>, options, print);
    case 'Literal.Location':
      return printLiteralLocation(path as FastPath<LiteralLocationNode>, options, print);
    case 'Literal.Rational':
      return printLiteralRational(path as FastPath<LiteralRationalNode>, options, print);
    case 'Literal.Real':
      return printLiteralReal(path as FastPath<LiteralRealNode>, options, print);
    case 'Literal.RegExp':
      return printLiteralRegExp(path as FastPath<LiteralRegExpNode>, options, print);
    case 'Literal.String':
      return printLiteralString(path as FastPath<LiteralStringNode>, options, print);
    case 'LocalVariableDeclaration.Default':
      return printLocalVariableDeclarationDefault(path as FastPath<LocalVariableDeclarationDefaultNode>, options, print);
    case 'LocalVariableDeclaration.Dynamic':
      return printLocalVariableDeclarationDynamic(path as FastPath<LocalVariableDeclarationDynamicNode>, options, print);
    case 'LocationLiteral.Default':
      return printLocationLiteralDefault(path as FastPath<LocationLiteralDefaultNode>, options, print);
    case 'Mapping_Expression.Default':
      return printMapping_ExpressionDefault(path as FastPath<Mapping_ExpressionDefaultNode>, options, print);
    case 'MidPathChars.Lexical':
      return printMidPathCharsLexical(path as FastPath<MidPathCharsLexicalNode>, options, print);
    case 'MidProtocolChars.Lexical':
      return printMidProtocolCharsLexical(path as FastPath<MidProtocolCharsLexicalNode>, options, print);
    case 'MidStringChars.Lexical':
      return printMidStringCharsLexical(path as FastPath<MidStringCharsLexicalNode>, options, print);
    case 'Module.Default':
      return printModuleDefault(path as FastPath<ModuleDefaultNode>, options, print);
    case 'ModuleActuals.Default':
      return printModuleActualsDefault(path as FastPath<ModuleActualsDefaultNode>, options, print);
    case 'ModuleParameters.Default':
      return printModuleParametersDefault(path as FastPath<ModuleParametersDefaultNode>, options, print);
    case 'Name.Lexical':
      return printNameLexical(path as FastPath<NameLexicalNode>, options, print);
    case 'NamedBackslash.Lexical':
      return printNamedBackslashLexical(path as FastPath<NamedBackslashLexicalNode>, options, print);
    case 'NamedRegExp.Lexical':
      return printNamedRegExpLexical(path as FastPath<NamedRegExpLexicalNode>, options, print);
    case 'Nonterminal.Lexical':
      return printNonterminalLexical(path as FastPath<NonterminalLexicalNode>, options, print);
    case 'NonterminalLabel.Lexical':
      return printNonterminalLabelLexical(path as FastPath<NonterminalLabelLexicalNode>, options, print);
    case 'OctalIntegerLiteral.Lexical':
      return printOctalIntegerLiteralLexical(path as FastPath<OctalIntegerLiteralLexicalNode>, options, print);
    case 'OptionalComma.Lexical':
      return printOptionalCommaLexical(path as FastPath<OptionalCommaLexicalNode>, options, print);
    case 'OptionalExpression.Expression':
      return printOptionalExpressionExpression(path as FastPath<OptionalExpressionExpressionNode>, options, print);
    case 'OptionalExpression.NoExpression':
      return printOptionalExpressionNoExpression(path as FastPath<OptionalExpressionNoExpressionNode>, options, print);
    case 'Output.Lexical':
      return printOutputLexical(path as FastPath<OutputLexicalNode>, options, print);
    case 'Parameters.Default':
      return printParametersDefault(path as FastPath<ParametersDefaultNode>, options, print);
    case 'Parameters.VarArgs':
      return printParametersVarArgs(path as FastPath<ParametersVarArgsNode>, options, print);
    case 'PathChars.Lexical':
      return printPathCharsLexical(path as FastPath<PathCharsLexicalNode>, options, print);
    case 'PathPart.Interpolated':
      return printPathPartInterpolated(path as FastPath<PathPartInterpolatedNode>, options, print);
    case 'PathPart.NonInterpolated':
      return printPathPartNonInterpolated(path as FastPath<PathPartNonInterpolatedNode>, options, print);
    case 'PathTail.Mid':
      return printPathTailMid(path as FastPath<PathTailMidNode>, options, print);
    case 'PathTail.Post':
      return printPathTailPost(path as FastPath<PathTailPostNode>, options, print);
    case 'PatternWithAction.Arbitrary':
      return printPatternWithActionArbitrary(path as FastPath<PatternWithActionArbitraryNode>, options, print);
    case 'PatternWithAction.Replacing':
      return printPatternWithActionReplacing(path as FastPath<PatternWithActionReplacingNode>, options, print);
    case 'PostPathChars.Lexical':
      return printPostPathCharsLexical(path as FastPath<PostPathCharsLexicalNode>, options, print);
    case 'PostProtocolChars.Lexical':
      return printPostProtocolCharsLexical(path as FastPath<PostProtocolCharsLexicalNode>, options, print);
    case 'PostStringChars.Lexical':
      return printPostStringCharsLexical(path as FastPath<PostStringCharsLexicalNode>, options, print);
    case 'PrePathChars.Lexical':
      return printPrePathCharsLexical(path as FastPath<PrePathCharsLexicalNode>, options, print);
    case 'PreProtocolChars.Lexical':
      return printPreProtocolCharsLexical(path as FastPath<PreProtocolCharsLexicalNode>, options, print);
    case 'PreStringChars.Lexical':
      return printPreStringCharsLexical(path as FastPath<PreStringCharsLexicalNode>, options, print);
    case 'Prod.All':
      return printProdAll(path as FastPath<ProdAllNode>, options, print);
    case 'Prod.AssociativityGroup':
      return printProdAssociativityGroup(path as FastPath<ProdAssociativityGroupNode>, options, print);
    case 'Prod.First':
      return printProdFirst(path as FastPath<ProdFirstNode>, options, print);
    case 'Prod.Labeled':
      return printProdLabeled(path as FastPath<ProdLabeledNode>, options, print);
    case 'Prod.Reference':
      return printProdReference(path as FastPath<ProdReferenceNode>, options, print);
    case 'Prod.Unlabeled':
      return printProdUnlabeled(path as FastPath<ProdUnlabeledNode>, options, print);
    case 'ProdModifier.Associativity':
      return printProdModifierAssociativity(path as FastPath<ProdModifierAssociativityNode>, options, print);
    case 'ProdModifier.Bracket':
      return printProdModifierBracket(path as FastPath<ProdModifierBracketNode>, options, print);
    case 'ProdModifier.Tag':
      return printProdModifierTag(path as FastPath<ProdModifierTagNode>, options, print);
    case 'ProtocolChars.Lexical':
      return printProtocolCharsLexical(path as FastPath<ProtocolCharsLexicalNode>, options, print);
    case 'ProtocolPart.Interpolated':
      return printProtocolPartInterpolated(path as FastPath<ProtocolPartInterpolatedNode>, options, print);
    case 'ProtocolPart.NonInterpolated':
      return printProtocolPartNonInterpolated(path as FastPath<ProtocolPartNonInterpolatedNode>, options, print);
    case 'ProtocolTail.Mid':
      return printProtocolTailMid(path as FastPath<ProtocolTailMidNode>, options, print);
    case 'ProtocolTail.Post':
      return printProtocolTailPost(path as FastPath<ProtocolTailPostNode>, options, print);
    case 'QualifiedName.Default':
      return printQualifiedNameDefault(path as FastPath<QualifiedNameDefaultNode>, options, print);
    case 'Range.Character':
      return printRangeCharacter(path as FastPath<RangeCharacterNode>, options, print);
    case 'Range.FromTo':
      return printRangeFromTo(path as FastPath<RangeFromToNode>, options, print);
    case 'RationalLiteral.Lexical':
      return printRationalLiteralLexical(path as FastPath<RationalLiteralLexicalNode>, options, print);
    case 'RealLiteral.Lexical':
      return printRealLiteralLexical(path as FastPath<RealLiteralLexicalNode>, options, print);
    case 'RegExp.Lexical':
      return printRegExpLexical(path as FastPath<RegExpLexicalNode>, options, print);
    case 'RegExpLiteral.Lexical':
      return printRegExpLiteralLexical(path as FastPath<RegExpLiteralLexicalNode>, options, print);
    case 'RegExpModifier.Lexical':
      return printRegExpModifierLexical(path as FastPath<RegExpModifierLexicalNode>, options, print);
    case 'Renaming.Default':
      return printRenamingDefault(path as FastPath<RenamingDefaultNode>, options, print);
    case 'Renamings.Default':
      return printRenamingsDefault(path as FastPath<RenamingsDefaultNode>, options, print);
    case 'Replacement.Conditional':
      return printReplacementConditional(path as FastPath<ReplacementConditionalNode>, options, print);
    case 'Replacement.Unconditional':
      return printReplacementUnconditional(path as FastPath<ReplacementUnconditionalNode>, options, print);
    case 'ShellCommand.Clear':
      return printShellCommandClear(path as FastPath<ShellCommandClearNode>, options, print);
    case 'ShellCommand.Edit':
      return printShellCommandEdit(path as FastPath<ShellCommandEditNode>, options, print);
    case 'ShellCommand.Help':
      return printShellCommandHelp(path as FastPath<ShellCommandHelpNode>, options, print);
    case 'ShellCommand.History':
      return printShellCommandHistory(path as FastPath<ShellCommandHistoryNode>, options, print);
    case 'ShellCommand.ListDeclarations':
      return printShellCommandListDeclarations(path as FastPath<ShellCommandListDeclarationsNode>, options, print);
    case 'ShellCommand.ListModules':
      return printShellCommandListModules(path as FastPath<ShellCommandListModulesNode>, options, print);
    case 'ShellCommand.Quit':
      return printShellCommandQuit(path as FastPath<ShellCommandQuitNode>, options, print);
    case 'ShellCommand.SetOption':
      return printShellCommandSetOption(path as FastPath<ShellCommandSetOptionNode>, options, print);
    case 'ShellCommand.Test':
      return printShellCommandTest(path as FastPath<ShellCommandTestNode>, options, print);
    case 'ShellCommand.Undeclare':
      return printShellCommandUndeclare(path as FastPath<ShellCommandUndeclareNode>, options, print);
    case 'ShellCommand.Unimport':
      return printShellCommandUnimport(path as FastPath<ShellCommandUnimportNode>, options, print);
    case 'Signature.NoThrows':
      return printSignatureNoThrows(path as FastPath<SignatureNoThrowsNode>, options, print);
    case 'Signature.WithThrows':
      return printSignatureWithThrows(path as FastPath<SignatureWithThrowsNode>, options, print);
    case 'Start.Absent':
      return printStartAbsent(path as FastPath<StartAbsentNode>, options, print);
    case 'Start.Present':
      return printStartPresent(path as FastPath<StartPresentNode>, options, print);
    case 'Statement.Append':
      return printStatementAppend(path as FastPath<StatementAppendNode>, options, print);
    case 'Statement.Assert':
      return printStatementAssert(path as FastPath<StatementAssertNode>, options, print);
    case 'Statement.AssertWithMessage':
      return printStatementAssertWithMessage(path as FastPath<StatementAssertWithMessageNode>, options, print);
    case 'Statement.Assignment':
      return printStatementAssignment(path as FastPath<StatementAssignmentNode>, options, print);
    case 'Statement.Break':
      return printStatementBreak(path as FastPath<StatementBreakNode>, options, print);
    case 'Statement.Continue':
      return printStatementContinue(path as FastPath<StatementContinueNode>, options, print);
    case 'Statement.DoWhile':
      return printStatementDoWhile(path as FastPath<StatementDoWhileNode>, options, print);
    case 'Statement.EmptyStatement':
      return printStatementEmptyStatement(path as FastPath<StatementEmptyStatementNode>, options, print);
    case 'Statement.Expression':
      return printStatementExpression(path as FastPath<StatementExpressionNode>, options, print);
    case 'Statement.Fail':
      return printStatementFail(path as FastPath<StatementFailNode>, options, print);
    case 'Statement.Filter':
      return printStatementFilter(path as FastPath<StatementFilterNode>, options, print);
    case 'Statement.For':
      return printStatementFor(path as FastPath<StatementForNode>, options, print);
    case 'Statement.FunctionDeclaration':
      return printStatementFunctionDeclaration(path as FastPath<StatementFunctionDeclarationNode>, options, print);
    case 'Statement.GlobalDirective':
      return printStatementGlobalDirective(path as FastPath<StatementGlobalDirectiveNode>, options, print);
    case 'Statement.IfThen':
      return printStatementIfThen(path as FastPath<StatementIfThenNode>, options, print);
    case 'Statement.IfThenElse':
      return printStatementIfThenElse(path as FastPath<StatementIfThenElseNode>, options, print);
    case 'Statement.Insert':
      return printStatementInsert(path as FastPath<StatementInsertNode>, options, print);
    case 'Statement.NonEmptyBlock':
      return printStatementNonEmptyBlock(path as FastPath<StatementNonEmptyBlockNode>, options, print);
    case 'Statement.Return':
      return printStatementReturn(path as FastPath<StatementReturnNode>, options, print);
    case 'Statement.Solve':
      return printStatementSolve(path as FastPath<StatementSolveNode>, options, print);
    case 'Statement.Switch':
      return printStatementSwitch(path as FastPath<StatementSwitchNode>, options, print);
    case 'Statement.Throw':
      return printStatementThrow(path as FastPath<StatementThrowNode>, options, print);
    case 'Statement.Try':
      return printStatementTry(path as FastPath<StatementTryNode>, options, print);
    case 'Statement.TryFinally':
      return printStatementTryFinally(path as FastPath<StatementTryFinallyNode>, options, print);
    case 'Statement.VariableDeclaration':
      return printStatementVariableDeclaration(path as FastPath<StatementVariableDeclarationNode>, options, print);
    case 'Statement.Visit':
      return printStatementVisit(path as FastPath<StatementVisitNode>, options, print);
    case 'Statement.While':
      return printStatementWhile(path as FastPath<StatementWhileNode>, options, print);
    case 'Strategy.BottomUp':
      return printStrategyBottomUp(path as FastPath<StrategyBottomUpNode>, options, print);
    case 'Strategy.BottomUpBreak':
      return printStrategyBottomUpBreak(path as FastPath<StrategyBottomUpBreakNode>, options, print);
    case 'Strategy.Innermost':
      return printStrategyInnermost(path as FastPath<StrategyInnermostNode>, options, print);
    case 'Strategy.Outermost':
      return printStrategyOutermost(path as FastPath<StrategyOutermostNode>, options, print);
    case 'Strategy.TopDown':
      return printStrategyTopDown(path as FastPath<StrategyTopDownNode>, options, print);
    case 'Strategy.TopDownBreak':
      return printStrategyTopDownBreak(path as FastPath<StrategyTopDownBreakNode>, options, print);
    case 'StringCharacter.Lexical':
      return printStringCharacterLexical(path as FastPath<StringCharacterLexicalNode>, options, print);
    case 'StringConstant.Lexical':
      return printStringConstantLexical(path as FastPath<StringConstantLexicalNode>, options, print);
    case 'StringLiteral.Interpolated':
      return printStringLiteralInterpolated(path as FastPath<StringLiteralInterpolatedNode>, options, print);
    case 'StringLiteral.NonInterpolated':
      return printStringLiteralNonInterpolated(path as FastPath<StringLiteralNonInterpolatedNode>, options, print);
    case 'StringLiteral.Template':
      return printStringLiteralTemplate(path as FastPath<StringLiteralTemplateNode>, options, print);
    case 'StringMiddle.Interpolated':
      return printStringMiddleInterpolated(path as FastPath<StringMiddleInterpolatedNode>, options, print);
    case 'StringMiddle.Mid':
      return printStringMiddleMid(path as FastPath<StringMiddleMidNode>, options, print);
    case 'StringMiddle.Template':
      return printStringMiddleTemplate(path as FastPath<StringMiddleTemplateNode>, options, print);
    case 'StringTail.MidInterpolated':
      return printStringTailMidInterpolated(path as FastPath<StringTailMidInterpolatedNode>, options, print);
    case 'StringTail.MidTemplate':
      return printStringTailMidTemplate(path as FastPath<StringTailMidTemplateNode>, options, print);
    case 'StringTail.Post':
      return printStringTailPost(path as FastPath<StringTailPostNode>, options, print);
    case 'StringTemplate.DoWhile':
      return printStringTemplateDoWhile(path as FastPath<StringTemplateDoWhileNode>, options, print);
    case 'StringTemplate.For':
      return printStringTemplateFor(path as FastPath<StringTemplateForNode>, options, print);
    case 'StringTemplate.IfThen':
      return printStringTemplateIfThen(path as FastPath<StringTemplateIfThenNode>, options, print);
    case 'StringTemplate.IfThenElse':
      return printStringTemplateIfThenElse(path as FastPath<StringTemplateIfThenElseNode>, options, print);
    case 'StringTemplate.While':
      return printStringTemplateWhile(path as FastPath<StringTemplateWhileNode>, options, print);
    case 'StructuredType.Default':
      return printStructuredTypeDefault(path as FastPath<StructuredTypeDefaultNode>, options, print);
    case 'Sym.Alternative':
      return printSymAlternative(path as FastPath<SymAlternativeNode>, options, print);
    case 'Sym.CaseInsensitiveLiteral':
      return printSymCaseInsensitiveLiteral(path as FastPath<SymCaseInsensitiveLiteralNode>, options, print);
    case 'Sym.CharacterClass':
      return printSymCharacterClass(path as FastPath<SymCharacterClassNode>, options, print);
    case 'Sym.Column':
      return printSymColumn(path as FastPath<SymColumnNode>, options, print);
    case 'Sym.Empty':
      return printSymEmpty(path as FastPath<SymEmptyNode>, options, print);
    case 'Sym.EndOfLine':
      return printSymEndOfLine(path as FastPath<SymEndOfLineNode>, options, print);
    case 'Sym.Except':
      return printSymExcept(path as FastPath<SymExceptNode>, options, print);
    case 'Sym.Follow':
      return printSymFollow(path as FastPath<SymFollowNode>, options, print);
    case 'Sym.Iter':
      return printSymIter(path as FastPath<SymIterNode>, options, print);
    case 'Sym.IterSep':
      return printSymIterSep(path as FastPath<SymIterSepNode>, options, print);
    case 'Sym.IterStar':
      return printSymIterStar(path as FastPath<SymIterStarNode>, options, print);
    case 'Sym.IterStarSep':
      return printSymIterStarSep(path as FastPath<SymIterStarSepNode>, options, print);
    case 'Sym.Labeled':
      return printSymLabeled(path as FastPath<SymLabeledNode>, options, print);
    case 'Sym.Literal':
      return printSymLiteral(path as FastPath<SymLiteralNode>, options, print);
    case 'Sym.Nonterminal':
      return printSymNonterminal(path as FastPath<SymNonterminalNode>, options, print);
    case 'Sym.NotFollow':
      return printSymNotFollow(path as FastPath<SymNotFollowNode>, options, print);
    case 'Sym.NotPrecede':
      return printSymNotPrecede(path as FastPath<SymNotPrecedeNode>, options, print);
    case 'Sym.Optional':
      return printSymOptional(path as FastPath<SymOptionalNode>, options, print);
    case 'Sym.Parameter':
      return printSymParameter(path as FastPath<SymParameterNode>, options, print);
    case 'Sym.Parametrized':
      return printSymParametrized(path as FastPath<SymParametrizedNode>, options, print);
    case 'Sym.Precede':
      return printSymPrecede(path as FastPath<SymPrecedeNode>, options, print);
    case 'Sym.Sequence':
      return printSymSequence(path as FastPath<SymSequenceNode>, options, print);
    case 'Sym.Start':
      return printSymStart(path as FastPath<SymStartNode>, options, print);
    case 'Sym.StartOfLine':
      return printSymStartOfLine(path as FastPath<SymStartOfLineNode>, options, print);
    case 'Sym.Unequal':
      return printSymUnequal(path as FastPath<SymUnequalNode>, options, print);
    case 'SyntaxDefinition.Keyword':
      return printSyntaxDefinitionKeyword(path as FastPath<SyntaxDefinitionKeywordNode>, options, print);
    case 'SyntaxDefinition.Language':
      return printSyntaxDefinitionLanguage(path as FastPath<SyntaxDefinitionLanguageNode>, options, print);
    case 'SyntaxDefinition.Layout':
      return printSyntaxDefinitionLayout(path as FastPath<SyntaxDefinitionLayoutNode>, options, print);
    case 'SyntaxDefinition.Lexical':
      return printSyntaxDefinitionLexical(path as FastPath<SyntaxDefinitionLexicalNode>, options, print);
    case 'Tag.Default':
      return printTagDefault(path as FastPath<TagDefaultNode>, options, print);
    case 'Tag.Empty':
      return printTagEmpty(path as FastPath<TagEmptyNode>, options, print);
    case 'Tag.Expression':
      return printTagExpression(path as FastPath<TagExpressionNode>, options, print);
    case 'TagString.Lexical':
      return printTagStringLexical(path as FastPath<TagStringLexicalNode>, options, print);
    case 'Tags.Default':
      return printTagsDefault(path as FastPath<TagsDefaultNode>, options, print);
    case 'Target.Empty':
      return printTargetEmpty(path as FastPath<TargetEmptyNode>, options, print);
    case 'Target.Labeled':
      return printTargetLabeled(path as FastPath<TargetLabeledNode>, options, print);
    case 'TimePartNoTZ.Lexical':
      return printTimePartNoTZLexical(path as FastPath<TimePartNoTZLexicalNode>, options, print);
    case 'TimeZonePart.Lexical':
      return printTimeZonePartLexical(path as FastPath<TimeZonePartLexicalNode>, options, print);
    case 'Toplevel.GivenVisibility':
      return printToplevelGivenVisibility(path as FastPath<ToplevelGivenVisibilityNode>, options, print);
    case 'Type.Basic':
      return printTypeBasic(path as FastPath<TypeBasicNode>, options, print);
    case 'Type.Bracket':
      return printTypeBracket(path as FastPath<TypeBracketNode>, options, print);
    case 'Type.Function':
      return printTypeFunction(path as FastPath<TypeFunctionNode>, options, print);
    case 'Type.Selector':
      return printTypeSelector(path as FastPath<TypeSelectorNode>, options, print);
    case 'Type.Structured':
      return printTypeStructured(path as FastPath<TypeStructuredNode>, options, print);
    case 'Type.Symbol':
      return printTypeSymbol(path as FastPath<TypeSymbolNode>, options, print);
    case 'Type.User':
      return printTypeUser(path as FastPath<TypeUserNode>, options, print);
    case 'Type.Variable':
      return printTypeVariable(path as FastPath<TypeVariableNode>, options, print);
    case 'TypeArg.Default':
      return printTypeArgDefault(path as FastPath<TypeArgDefaultNode>, options, print);
    case 'TypeArg.Named':
      return printTypeArgNamed(path as FastPath<TypeArgNamedNode>, options, print);
    case 'TypeVar.Bounded':
      return printTypeVarBounded(path as FastPath<TypeVarBoundedNode>, options, print);
    case 'TypeVar.Free':
      return printTypeVarFree(path as FastPath<TypeVarFreeNode>, options, print);
    case 'URLChars.Lexical':
      return printURLCharsLexical(path as FastPath<URLCharsLexicalNode>, options, print);
    case 'UnicodeEscape.Lexical':
      return printUnicodeEscapeLexical(path as FastPath<UnicodeEscapeLexicalNode>, options, print);
    case 'UserType.Name':
      return printUserTypeName(path as FastPath<UserTypeNameNode>, options, print);
    case 'UserType.Parametric':
      return printUserTypeParametric(path as FastPath<UserTypeParametricNode>, options, print);
    case 'Variable.Initialized':
      return printVariableInitialized(path as FastPath<VariableInitializedNode>, options, print);
    case 'Variable.UnInitialized':
      return printVariableUnInitialized(path as FastPath<VariableUnInitializedNode>, options, print);
    case 'Variant.NAryConstructor':
      return printVariantNAryConstructor(path as FastPath<VariantNAryConstructorNode>, options, print);
    case 'Visibility.Default':
      return printVisibilityDefault(path as FastPath<VisibilityDefaultNode>, options, print);
    case 'Visibility.Private':
      return printVisibilityPrivate(path as FastPath<VisibilityPrivateNode>, options, print);
    case 'Visibility.Public':
      return printVisibilityPublic(path as FastPath<VisibilityPublicNode>, options, print);
    case 'Visit.DefaultStrategy':
      return printVisitDefaultStrategy(path as FastPath<VisitDefaultStrategyNode>, options, print);
    case 'Visit.GivenStrategy':
      return printVisitGivenStrategy(path as FastPath<VisitGivenStrategyNode>, options, print);
  }
}
