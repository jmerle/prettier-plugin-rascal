import { doc, Doc, FastPath, ParserOptions } from 'prettier';

const { concat, join, group, indent, line, softline, hardline } = doc.builders;

export function printExpressionAdditionNode(
  node: ExpressionAdditionNode,
  path: FastPath<ExpressionAdditionNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Addition' is not implemented yet");
}

export function printExpressionAllNode(
  node: ExpressionAllNode,
  path: FastPath<ExpressionAllNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.All' is not implemented yet");
}

export function printExpressionAndNode(
  node: ExpressionAndNode,
  path: FastPath<ExpressionAndNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.And' is not implemented yet");
}

export function printExpressionAntiNode(
  node: ExpressionAntiNode,
  path: FastPath<ExpressionAntiNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Anti' is not implemented yet");
}

export function printExpressionAnyNode(
  node: ExpressionAnyNode,
  path: FastPath<ExpressionAnyNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Any' is not implemented yet");
}

export function printExpressionAppendAfterNode(
  node: ExpressionAppendAfterNode,
  path: FastPath<ExpressionAppendAfterNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.AppendAfter' is not implemented yet");
}

export function printExpressionAsTypeNode(
  node: ExpressionAsTypeNode,
  path: FastPath<ExpressionAsTypeNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.AsType' is not implemented yet");
}

export function printExpressionBracketNode(
  node: ExpressionBracketNode,
  path: FastPath<ExpressionBracketNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Bracket' is not implemented yet");
}

export function printExpressionCallOrTreeNode(
  node: ExpressionCallOrTreeNode,
  path: FastPath<ExpressionCallOrTreeNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.CallOrTree' is not implemented yet");
}

export function printExpressionClosureNode(
  node: ExpressionClosureNode,
  path: FastPath<ExpressionClosureNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Closure' is not implemented yet");
}

export function printExpressionCompositionNode(
  node: ExpressionCompositionNode,
  path: FastPath<ExpressionCompositionNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Composition' is not implemented yet");
}

export function printExpressionComprehensionNode(
  node: ExpressionComprehensionNode,
  path: FastPath<ExpressionComprehensionNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Comprehension' is not implemented yet");
}

export function printExpressionConcreteNode(
  node: ExpressionConcreteNode,
  path: FastPath<ExpressionConcreteNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Concrete' is not implemented yet");
}

export function printExpressionDescendantNode(
  node: ExpressionDescendantNode,
  path: FastPath<ExpressionDescendantNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Descendant' is not implemented yet");
}

export function printExpressionDivisionNode(
  node: ExpressionDivisionNode,
  path: FastPath<ExpressionDivisionNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Division' is not implemented yet");
}

export function printExpressionEnumeratorNode(
  node: ExpressionEnumeratorNode,
  path: FastPath<ExpressionEnumeratorNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Enumerator' is not implemented yet");
}

export function printExpressionEqualsNode(
  node: ExpressionEqualsNode,
  path: FastPath<ExpressionEqualsNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Equals' is not implemented yet");
}

export function printExpressionEquivalenceNode(
  node: ExpressionEquivalenceNode,
  path: FastPath<ExpressionEquivalenceNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Equivalence' is not implemented yet");
}

export function printExpressionFieldAccessNode(
  node: ExpressionFieldAccessNode,
  path: FastPath<ExpressionFieldAccessNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.FieldAccess' is not implemented yet");
}

export function printExpressionFieldProjectNode(
  node: ExpressionFieldProjectNode,
  path: FastPath<ExpressionFieldProjectNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.FieldProject' is not implemented yet");
}

export function printExpressionFieldUpdateNode(
  node: ExpressionFieldUpdateNode,
  path: FastPath<ExpressionFieldUpdateNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.FieldUpdate' is not implemented yet");
}

export function printExpressionGetAnnotationNode(
  node: ExpressionGetAnnotationNode,
  path: FastPath<ExpressionGetAnnotationNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.GetAnnotation' is not implemented yet");
}

export function printExpressionGreaterThanNode(
  node: ExpressionGreaterThanNode,
  path: FastPath<ExpressionGreaterThanNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.GreaterThan' is not implemented yet");
}

export function printExpressionGreaterThanOrEqNode(
  node: ExpressionGreaterThanOrEqNode,
  path: FastPath<ExpressionGreaterThanOrEqNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.GreaterThanOrEq' is not implemented yet");
}

export function printExpressionHasNode(
  node: ExpressionHasNode,
  path: FastPath<ExpressionHasNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Has' is not implemented yet");
}

export function printExpressionIfDefinedOtherwiseNode(
  node: ExpressionIfDefinedOtherwiseNode,
  path: FastPath<ExpressionIfDefinedOtherwiseNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.IfDefinedOtherwise' is not implemented yet");
}

export function printExpressionIfThenElseNode(
  node: ExpressionIfThenElseNode,
  path: FastPath<ExpressionIfThenElseNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.IfThenElse' is not implemented yet");
}

export function printExpressionImplicationNode(
  node: ExpressionImplicationNode,
  path: FastPath<ExpressionImplicationNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Implication' is not implemented yet");
}

export function printExpressionInNode(
  node: ExpressionInNode,
  path: FastPath<ExpressionInNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.In' is not implemented yet");
}

export function printExpressionInsertBeforeNode(
  node: ExpressionInsertBeforeNode,
  path: FastPath<ExpressionInsertBeforeNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.InsertBefore' is not implemented yet");
}

export function printExpressionIntersectionNode(
  node: ExpressionIntersectionNode,
  path: FastPath<ExpressionIntersectionNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Intersection' is not implemented yet");
}

export function printExpressionIsNode(
  node: ExpressionIsNode,
  path: FastPath<ExpressionIsNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Is' is not implemented yet");
}

export function printExpressionIsDefinedNode(
  node: ExpressionIsDefinedNode,
  path: FastPath<ExpressionIsDefinedNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.IsDefined' is not implemented yet");
}

export function printExpressionItNode(
  node: ExpressionItNode,
  path: FastPath<ExpressionItNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.It' is not implemented yet");
}

export function printExpressionJoinNode(
  node: ExpressionJoinNode,
  path: FastPath<ExpressionJoinNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Join' is not implemented yet");
}

export function printExpressionLessThanNode(
  node: ExpressionLessThanNode,
  path: FastPath<ExpressionLessThanNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.LessThan' is not implemented yet");
}

export function printExpressionLessThanOrEqNode(
  node: ExpressionLessThanOrEqNode,
  path: FastPath<ExpressionLessThanOrEqNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.LessThanOrEq' is not implemented yet");
}

export function printExpressionListNode(
  node: ExpressionListNode,
  path: FastPath<ExpressionListNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.List' is not implemented yet");
}

export function printExpressionLiteralNode(
  node: ExpressionLiteralNode,
  path: FastPath<ExpressionLiteralNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Literal' is not implemented yet");
}

export function printExpressionMapNode(
  node: ExpressionMapNode,
  path: FastPath<ExpressionMapNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Map' is not implemented yet");
}

export function printExpressionMatchNode(
  node: ExpressionMatchNode,
  path: FastPath<ExpressionMatchNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Match' is not implemented yet");
}

export function printExpressionModuloNode(
  node: ExpressionModuloNode,
  path: FastPath<ExpressionModuloNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Modulo' is not implemented yet");
}

export function printExpressionMultiVariableNode(
  node: ExpressionMultiVariableNode,
  path: FastPath<ExpressionMultiVariableNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.MultiVariable' is not implemented yet");
}

export function printExpressionNegationNode(
  node: ExpressionNegationNode,
  path: FastPath<ExpressionNegationNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Negation' is not implemented yet");
}

export function printExpressionNegativeNode(
  node: ExpressionNegativeNode,
  path: FastPath<ExpressionNegativeNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Negative' is not implemented yet");
}

export function printExpressionNoMatchNode(
  node: ExpressionNoMatchNode,
  path: FastPath<ExpressionNoMatchNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.NoMatch' is not implemented yet");
}

export function printExpressionNonEmptyBlockNode(
  node: ExpressionNonEmptyBlockNode,
  path: FastPath<ExpressionNonEmptyBlockNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.NonEmptyBlock' is not implemented yet");
}

export function printExpressionNonEqualsNode(
  node: ExpressionNonEqualsNode,
  path: FastPath<ExpressionNonEqualsNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.NonEquals' is not implemented yet");
}

export function printExpressionNotInNode(
  node: ExpressionNotInNode,
  path: FastPath<ExpressionNotInNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.NotIn' is not implemented yet");
}

export function printExpressionOrNode(
  node: ExpressionOrNode,
  path: FastPath<ExpressionOrNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Or' is not implemented yet");
}

export function printExpressionProductNode(
  node: ExpressionProductNode,
  path: FastPath<ExpressionProductNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Product' is not implemented yet");
}

export function printExpressionQualifiedNameNode(
  node: ExpressionQualifiedNameNode,
  path: FastPath<ExpressionQualifiedNameNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.QualifiedName' is not implemented yet");
}

export function printExpressionRangeNode(
  node: ExpressionRangeNode,
  path: FastPath<ExpressionRangeNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Range' is not implemented yet");
}

export function printExpressionReducerNode(
  node: ExpressionReducerNode,
  path: FastPath<ExpressionReducerNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Reducer' is not implemented yet");
}

export function printExpressionReifiedTypeNode(
  node: ExpressionReifiedTypeNode,
  path: FastPath<ExpressionReifiedTypeNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.ReifiedType' is not implemented yet");
}

export function printExpressionReifyTypeNode(
  node: ExpressionReifyTypeNode,
  path: FastPath<ExpressionReifyTypeNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.ReifyType' is not implemented yet");
}

export function printExpressionRemainderNode(
  node: ExpressionRemainderNode,
  path: FastPath<ExpressionRemainderNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Remainder' is not implemented yet");
}

export function printExpressionSetNode(
  node: ExpressionSetNode,
  path: FastPath<ExpressionSetNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Set' is not implemented yet");
}

export function printExpressionSetAnnotationNode(
  node: ExpressionSetAnnotationNode,
  path: FastPath<ExpressionSetAnnotationNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.SetAnnotation' is not implemented yet");
}

export function printExpressionSliceNode(
  node: ExpressionSliceNode,
  path: FastPath<ExpressionSliceNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Slice' is not implemented yet");
}

export function printExpressionSliceStepNode(
  node: ExpressionSliceStepNode,
  path: FastPath<ExpressionSliceStepNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.SliceStep' is not implemented yet");
}

export function printExpressionSpliceNode(
  node: ExpressionSpliceNode,
  path: FastPath<ExpressionSpliceNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Splice' is not implemented yet");
}

export function printExpressionSplicePlusNode(
  node: ExpressionSplicePlusNode,
  path: FastPath<ExpressionSplicePlusNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.SplicePlus' is not implemented yet");
}

export function printExpressionStepRangeNode(
  node: ExpressionStepRangeNode,
  path: FastPath<ExpressionStepRangeNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.StepRange' is not implemented yet");
}

export function printExpressionSubscriptNode(
  node: ExpressionSubscriptNode,
  path: FastPath<ExpressionSubscriptNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Subscript' is not implemented yet");
}

export function printExpressionSubtractionNode(
  node: ExpressionSubtractionNode,
  path: FastPath<ExpressionSubtractionNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Subtraction' is not implemented yet");
}

export function printExpressionTransitiveClosureNode(
  node: ExpressionTransitiveClosureNode,
  path: FastPath<ExpressionTransitiveClosureNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.TransitiveClosure' is not implemented yet");
}

export function printExpressionTransitiveReflexiveClosureNode(
  node: ExpressionTransitiveReflexiveClosureNode,
  path: FastPath<ExpressionTransitiveReflexiveClosureNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.TransitiveReflexiveClosure' is not implemented yet");
}

export function printExpressionTupleNode(
  node: ExpressionTupleNode,
  path: FastPath<ExpressionTupleNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Tuple' is not implemented yet");
}

export function printExpressionTypedVariableNode(
  node: ExpressionTypedVariableNode,
  path: FastPath<ExpressionTypedVariableNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.TypedVariable' is not implemented yet");
}

export function printExpressionTypedVariableBecomesNode(
  node: ExpressionTypedVariableBecomesNode,
  path: FastPath<ExpressionTypedVariableBecomesNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.TypedVariableBecomes' is not implemented yet");
}

export function printExpressionVariableBecomesNode(
  node: ExpressionVariableBecomesNode,
  path: FastPath<ExpressionVariableBecomesNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.VariableBecomes' is not implemented yet");
}

export function printExpressionVisitNode(
  node: ExpressionVisitNode,
  path: FastPath<ExpressionVisitNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.Visit' is not implemented yet");
}

export function printExpressionVoidClosureNode(
  node: ExpressionVoidClosureNode,
  path: FastPath<ExpressionVoidClosureNode>,
  options: ParserOptions,
  print: (path: FastPath<ASTNode>) => Doc,
): Doc {
  // TODO(jmerle): Implement
  console.log(node);
  throw new Error("Node type 'Expression.VoidClosure' is not implemented yet");
}
